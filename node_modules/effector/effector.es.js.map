{"version":3,"file":"effector.es.js","sources":["node_modules/effector/stdlib/graph.js","node_modules/effector/naming.js","node_modules/effector/compositeName.js","node_modules/effector/thru.js","node_modules/effector/watcher/watcher.js","node_modules/effector/event/eventFabric.js","node_modules/effector/config.js","node_modules/effector/event/createEvent.js","node_modules/effector/event/fromObservable.js","node_modules/effector/perf/perf.js","node_modules/effector/store/storeMethods.js","node_modules/effector/store/storeFabric.js","node_modules/effector/store/createStore.js","node_modules/effector/store/setStoreName.js","node_modules/effector/store/createStoreObject.js","node_modules/effector/store/createApi.js","node_modules/effector/store/restore.js","node_modules/effector/store/staticMethods.js","node_modules/effector/combine.js","node_modules/effector/sample.js","node_modules/effector/effect/effectFabric.js","node_modules/effector/effect/createEffect.js","node_modules/effector/domain/createDomain.js","node_modules/effector/domain/domainFabric.js","node_modules/effector/domain/hook.js","node_modules/effector/flags.prod.js","node_modules/effector/validate/invariant.js","node_modules/effector/stdlib/kind.js","node_modules/effector/stdlib/refcount.js","node_modules/effector/stdlib/typedef.js","node_modules/effector/stdlib/stateref.js","node_modules/effector/stdlib/commonRefcount.js","node_modules/effector/kernel/getPriority.js","node_modules/effector/kernel/kernel.js","node_modules/effector/blocks.js","node_modules/effector/validate/warning.js","node_modules/effector/validate/is.js","node_modules/effector/event/forward.js"],"sourcesContent":["//@flow\n\nimport type {Graph, Graphite, Cmd} from './index.h'\n\nexport function createGraph({\n  node,\n  child = [],\n  from = [],\n  scope = {},\n  meta = {},\n}: {\n  +node: Array<Cmd>,\n  +child?: Array<Graphite>,\n  +from?: Array<Graphite>,\n  scope?: {[name: string]: any, ...},\n  meta?: {[name: string]: any, ...},\n  ...\n}): Graph {\n  return {\n    from: from.map(getGraph),\n    seq: node,\n    next: child.map(getGraph),\n    meta,\n    scope,\n  }\n}\nexport const clearNode = (\n  graphite: Graphite,\n  {deep}: {\n    deep?: boolean,\n    ...\n  } = {},\n) => {\n  const graph = getGraph(graphite)\n  if (deep) {\n    graph.next.forEach(node => clearNode(node, {deep}))\n  }\n  graph.from.forEach(node => {\n    const index = node.next.indexOf(graph)\n    if (index === -1) return\n    node.next.splice(index, 1)\n  })\n  graph.from.length = 0\n  graph.next.length = 0\n  graph.seq.length = 0\n  //$off\n  graph.scope = null\n}\n\nexport const getGraph = (graph: Graphite): Graph =>\n  (graph: any).graphite || graph\n\nexport const traverse = (\n  graphite: Graphite,\n  {ctx, pre, post}: {ctx: any, pre: Function, post: Function, ...},\n) => {\n  const visited = new Set()\n  const stack = []\n  const walk = (step, layer) => {\n    if (visited.has(step)) return\n    stack.push(step)\n    visited.add(step)\n    pre(step, ctx, stack, layer)\n    const steps = step.next\n    for (let i = 0; i < steps.length; i++) {\n      walk(steps[i], steps)\n    }\n    stack.pop()\n    post(step, ctx, stack, layer)\n  }\n  const graph = getGraph(graphite)\n  walk(graph, [graph])\n  visited.clear()\n  return ctx\n}\n","//@flow\n\nimport type {CompositeName} from './compositeName'\nimport {is} from './validate'\nimport type {Store} from './store'\nimport type {Event} from './event'\nimport type {Effect} from './effect'\n\nexport function getDisplayName(unit: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (unit.compositeName) {\n    return unit.compositeName.fullName\n  }\n  if (unit.domainName) {\n    return unit.domainName.fullName\n  }\n  return unit.id\n}\n\nconst unitObjectMaxNames = 25\n\nexport function unitObjectName(\n  objOrArr:\n    | $ReadOnlyArray<Store<any> | Event<any> | Effect<any, any, any> | any>\n    | {\n        [key: string]: Store<any> | Event<any> | Effect<any, any, any> | any,\n        ...\n      },\n) {\n  let i = 0\n  const arr: Array<any> = Object.values(objOrArr)\n  const max = unitObjectMaxNames - 1\n  const maxLength = arr.length - 1\n  let name = 'combine('\n  for (const unit of arr) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    if (is.store(unit) || is.event(unit) || is.effect(unit)) {\n      name += getDisplayName(unit) + comma\n    } else {\n      name += unit.toString() + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n","//@flow\n\nexport type CompositeName = {|\n  +shortName: string,\n  +fullName: string,\n  +path: Array<string>,\n|}\n\nfunction Name(shortName: string, fullName: string, path: Array<string>) {\n  this.shortName = shortName\n  this.fullName = fullName\n  this.path = path\n}\n\nexport function createName(name: string, parent?: CompositeName) {\n  let path\n  let fullName\n  const shortName = name\n  if (parent === undefined) {\n    if (name.length === 0) {\n      path = ([]: string[])\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    if (name.length === 0) {\n      path = parent.path\n      fullName = parent.fullName\n    } else {\n      path = parent.path.concat([name])\n      if (parent.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + parent.fullName + '/' + name\n      }\n    }\n  }\n  return new Name(shortName, fullName, path)\n}\n","//@flow\n\nexport function thru(fn: Function) {\n  return fn(this)\n}\n","//@flow\n\nimport type {TypeDef, Graph} from '../stdlib'\nimport type {Watcher} from './index.h'\n\nconst noopIndexOf = () => -1\n//eslint-disable-next-line no-unused-vars\nconst noopSplice = (i: number, n: number) => []\n\nfunction disposer() {\n  const i = this.indexOf()\n  if (i === -1) return\n  this.splice(i, 1)\n  this.indexOf = noopIndexOf\n  this.splice = noopSplice\n}\n\nexport const createWatcher = (opts: {|child: Graph, parent: Graph|}): Watcher => {\n  const subscribers = opts.parent.next\n  const instance = {\n    indexOf: subscribers.indexOf.bind(subscribers, opts.child),\n    splice: subscribers.splice.bind(subscribers),\n  }\n  const result = disposer.bind(instance)\n  result.unsubscribe = disposer.bind(instance)\n  return (result: $todo)\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport {step, Kind, stringRefcount, createGraph, type Unit} from '../stdlib'\nimport type {Effect} from '../effect'\nimport {launch} from '../kernel'\nimport {noop} from '../blocks'\n\nimport {getDisplayName} from '../naming'\nimport type {Subscription} from '../index.h'\nimport type {EventConfigPart} from '../config'\nimport type {Event} from './index.h'\nimport {type CompositeName, createName} from '../compositeName'\nimport {thru} from '../thru'\nimport {createLink} from './forward'\n\nconst nextID = stringRefcount()\n\nexport function eventFabric<Payload>({\n  name: nameRaw,\n  parent,\n  config = {},\n}: {\n  name?: string,\n  parent?: CompositeName,\n  config?: EventConfigPart,\n  ...\n}): Event<Payload> {\n  const id = nextID()\n  const name = nameRaw || id\n  const compositeName = createName(name, parent)\n  const fullName = compositeName.fullName\n  const graphite = createGraph({\n    node: [\n      step.emit({\n        fullName,\n      }),\n    ],\n  })\n\n  //$off\n  const instance: Event<Payload> = (\n    payload: Payload,\n    ...args: any[]\n  ): Payload => instance.create(payload, fullName, args)\n  ;(instance: any).getType = () => fullName\n  //eslint-disable-next-line no-unused-vars\n  ;(instance: any).create = (payload, fullName, args) => {\n    launch(instance, payload)\n    return payload\n  }\n  ;(instance: any).kind = Kind.event\n  ;(instance: any)[$$observable] = () => instance\n  ;(instance: any).id = id\n  ;(instance: any).watch = watchEvent.bind(null, instance)\n  ;(instance: any).map = mapEvent.bind(null, instance)\n  ;(instance: any).filter = filterEvent.bind(null, instance)\n  ;(instance: any).prepend = prepend.bind(null, instance)\n  ;(instance: any).subscribe = subscribe.bind(null, instance)\n  ;(instance: any).thru = thru.bind(instance)\n  instance.graphite = graphite\n  instance.shortName = name\n  instance.domainName = parent\n  instance.compositeName = compositeName\n  instance.defaultConfig = config\n\n  return instance\n}\n\nfunction subscribe(event, observer): Subscription {\n  return event.watch(payload => observer.next(payload))\n}\n\nfunction prepend(event, fn: (_: any) => *) {\n  const contramapped: Event<any> = eventFabric({\n    name: '* → ' + event.shortName,\n    parent: event.domainName,\n  })\n  createLink(contramapped, {\n    child: [event],\n    scope: {handler: fn},\n    node: [\n      step.compute({\n        fn: (newValue, {handler}) => handler(newValue),\n      }),\n    ],\n  })\n  return contramapped\n}\n\ndeclare function mapEvent<A, B>(event: Event<A>, fn: (_: A) => B): Event<B>\ndeclare function mapEvent<A, B>(\n  effect: Effect<A, any, any>,\n  fn: (_: A) => B,\n): Event<B>\nfunction mapEvent<A, B>(event: Event<A> | Effect<A, any, any>, fn: A => B) {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' → *',\n    parent: event.domainName,\n  })\n  createLink(event, {\n    child: [mapped],\n    scope: {handler: fn},\n    node: [\n      step.compute({\n        fn: (payload, {handler}) => handler(payload),\n      }),\n    ],\n  })\n  return mapped\n}\n\nfunction filterEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn: {|fn(_: any): boolean|} | (any => any | void),\n): any {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' →? *',\n    parent: event.domainName,\n  })\n  let node\n  let scope\n  //null values not allowed\n  if (typeof fn === 'object') {\n    scope = {fn: fn.fn}\n    node = [\n      step.filter({\n        fn: (upd, {fn}) => fn(upd),\n      }),\n    ]\n  } else {\n    scope = {fn}\n    node = [\n      step.compute({\n        fn: (payload, {fn}) => fn(payload),\n      }),\n      step.filter({\n        fn: result => result !== undefined,\n      }),\n    ]\n  }\n  createLink(event, {\n    scope,\n    child: [mapped],\n    node,\n  })\n  return mapped\n}\n\nfunction watchEvent<Payload>(\n  event: Unit,\n  watcher: (payload: Payload, type: string) => any,\n): Subscription {\n  return createLink(event, {\n    scope: {trigger: event, handler: watcher},\n    //prettier-ignore\n    node: [\n      noop,\n      step.run({\n        fn: (payload: Payload, {trigger, handler}) => handler(\n          payload,\n          getDisplayName(trigger),\n        ),\n      }),\n    ]\n  })\n}\n","//@flow\n\nimport warning from 'warning'\n\nexport type SourceLocation = {|\n  file: string,\n  column: number,\n  line: number,\n|}\n\nexport type EffectConfigPart<Payload, Done> = {\n  handler?: (payload: Payload) => Promise<Done> | Done,\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type StoreConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type EventConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type DomainConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type Config<Part> = {\n  ɔ?: Part,\n  ...Part,\n  ...\n}\n\ndeclare export function normalizeConfig<Payload, Done>(\n  config?: Config<EffectConfigPart<Payload, Done>>,\n): EffectConfigPart<Payload, Done>\ndeclare export function normalizeConfig(\n  config?: Config<StoreConfigPart>,\n): StoreConfigPart\ndeclare export function normalizeConfig(\n  config?: Config<EventConfigPart>,\n): EventConfigPart\ndeclare export function normalizeConfig(\n  config?: Config<DomainConfigPart>,\n): DomainConfigPart\nexport function normalizeConfig(config: any = {}): any {\n  const message =\n    'createStore: Second argument should be plain object, but you passed %s.'\n  warning(typeof config === 'object' && config !== null, message, config)\n  if (typeof config?.ɔ !== 'undefined') {\n    warning(\n      typeof config.ɔ === 'object' && config.ɔ !== null,\n      message,\n      config.ɔ,\n    )\n  }\n  const rawConfig = typeof config.ɔ === 'object' ? config.ɔ : {}\n  const newConfig = Object.assign({}, config, rawConfig)\n  delete newConfig.ɔ\n  return newConfig\n}\n\ndeclare export function normalizeEventConfig<Payload, Done>(\n  nameOrConfig?: string | EffectConfigPart<Payload, Done>,\n  config?: Config<EffectConfigPart<Payload, Done>>,\n): {|\n  config: EffectConfigPart<Payload, Done>,\n  name?: string,\n|}\ndeclare export function normalizeEventConfig(\n  nameOrConfig?: string | EventConfigPart,\n  config?: Config<EventConfigPart>,\n): {|\n  config: EventConfigPart,\n  name?: string,\n|}\ndeclare export function normalizeEventConfig(\n  nameOrConfig?: string | DomainConfigPart,\n  config?: Config<DomainConfigPart>,\n): {|\n  config: DomainConfigPart,\n  name?: string,\n|}\nexport function normalizeEventConfig(\n  nameOrConfig?: string | {...},\n  opts?: any,\n) {\n  const config =\n    typeof nameOrConfig === 'object'\n      ? Object.assign({}, normalizeConfig(opts), nameOrConfig)\n      : normalizeConfig(opts)\n  const name =\n    typeof nameOrConfig === 'object' || typeof nameOrConfig === 'undefined'\n      ? config.name\n      : nameOrConfig\n  return {\n    config,\n    name,\n  }\n}\n","//@flow\n\nimport {eventFabric} from './eventFabric'\nimport {\n  normalizeEventConfig,\n  type EventConfigPart,\n  type Config,\n} from '../config'\nimport type {Event} from './index.h'\n\nexport function createEvent<Payload>(\n  nameOrConfig?: string | EventConfigPart,\n  opts?: Config<EventConfigPart> = {},\n): Event<Payload> {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return eventFabric({\n    name,\n    config,\n  })\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport $$observable from 'symbol-observable'\nimport {clearNode} from '../stdlib'\nimport {createEvent} from './createEvent'\nimport type {Event} from './index.h'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  invariant(\n    typeof observable === 'function'\n      || (typeof observable === 'object' && observable !== null),\n    'expect observable to be object or function',\n  )\n  const observableItem: any =\n    //$off\n    ($$observable: '@@observable') in observable\n      ? //$off\n      observable[(($$observable: any): '@@observable')]()\n      : observable\n  invariant(\n    'subscribe' in observableItem,\n    'expect observable to have .subscribe',\n  )\n  const event: Event<T> = createEvent()\n  const disposer = clearNode.bind(null, event, {})\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\n\nimport {__DEV__} from 'effector/flags'\nimport type {CompositeName} from '../compositeName'\nimport {getDisplayName} from '../naming'\n\ntype StoreMeasurementPhase = 'map' | 'subscribe'\n\nlet currentPhase: StoreMeasurementPhase | null = null\nlet currentPhaseStore: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n} | null = null\n\nconst enableUserTimingAPI = __DEV__\n\nfunction startPhaseTimer(/*::\n  store: {\n    compositeName?: CompositeName,\n    domainName?: CompositeName,\n    +id: string,\n    ...\n  },\n  phase: StoreMeasurementPhase,\n*/) {}\n\nfunction stopPhaseTimer(/*::warning: string | null*/) {}\n\nif (enableUserTimingAPI) {\n  const effectorEmoji = '\\u2604'\n\n  const supportsUserTiming =\n    typeof performance !== 'undefined'\n    && typeof performance.mark === 'function'\n    && typeof performance.clearMarks === 'function'\n    && typeof performance.measure === 'function'\n    && typeof performance.clearMeasures === 'function'\n\n  function formatMarkName(markName: string) {\n    return `${effectorEmoji} ${markName}`\n  }\n\n  const formatLabel = (label: string, warning: string | null) => {\n    const prefix = `${effectorEmoji} `\n    const suffix = warning ? ` Warning: ${warning}` : ''\n    return `${prefix}${label}${suffix}`\n  }\n\n  function getStoreLabel(storeName: string, phase: StoreMeasurementPhase) {\n    return `${storeName}.${phase}`\n  }\n\n  function getStoreMarkName(label: string, debugID: string) {\n    return `${label} (#${debugID})`\n  }\n\n  function beginMark(markName: string) {\n    performance.mark(formatMarkName(markName))\n  }\n\n  function clearMark(markName: string) {\n    performance.clearMarks(formatMarkName(markName))\n  }\n\n  function endMark(label: string, markName: string, warning: string | null) {\n    const formattedMarkName = formatMarkName(markName)\n    const formattedLabel = formatLabel(label, warning)\n    try {\n      performance.measure(formattedLabel, formattedMarkName)\n    } catch (err) {}\n    // Clear marks immediately to avoid growing buffer.\n    performance.clearMarks(formattedMarkName)\n    performance.clearMeasures(formattedLabel)\n  }\n\n  function beginStoreMark(store, phase: StoreMeasurementPhase) {\n    const componentName = getDisplayName(store)\n    const debugID = store.id\n    const label = getStoreLabel(componentName, phase)\n    const markName = getStoreMarkName(label, debugID)\n    beginMark(markName)\n    return true\n  }\n\n  function clearStoreMark(store, phase: StoreMeasurementPhase) {\n    const componentName = getDisplayName(store)\n    const debugID = store.id\n    const label = getStoreLabel(componentName, phase)\n    const markName = getStoreMarkName(label, debugID)\n    clearMark(markName)\n  }\n\n  function endStoreMark(\n    store,\n    phase: StoreMeasurementPhase,\n    warning: string | null,\n  ) {\n    const componentName = getDisplayName(store)\n    const debugID = store.id\n    const label = getStoreLabel(componentName, phase)\n    const markName = getStoreMarkName(label, debugID)\n    endMark(label, markName, warning)\n  }\n\n  const clearPendingPhaseMeasurement = () => {\n    if (currentPhase !== null && currentPhaseStore !== null) {\n      clearStoreMark(currentPhaseStore, currentPhase)\n    }\n    currentPhaseStore = null\n    currentPhase = null\n    //hasScheduledUpdateInCurrentPhase = false\n  }\n\n  startPhaseTimer = function(\n    store: {\n      compositeName?: CompositeName,\n      domainName?: CompositeName,\n      /*::+*/ id: string,\n      /*::...*/\n    },\n    phase: StoreMeasurementPhase,\n  ): void {\n    if (!supportsUserTiming) {\n      return\n    }\n    clearPendingPhaseMeasurement()\n    if (!beginStoreMark(store, phase)) {\n      return\n    }\n    currentPhaseStore = store\n    currentPhase = phase\n  }\n\n  stopPhaseTimer = function(warning: string | null): void {\n    if (!supportsUserTiming) {\n      return\n    }\n    if (currentPhase !== null && currentPhaseStore !== null) {\n      endStoreMark(currentPhaseStore, currentPhase, warning)\n    }\n    currentPhase = null\n    currentPhaseStore = null\n  }\n}\n\nexport {startPhaseTimer, stopPhaseTimer}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport invariant from 'invariant'\nimport {step, readRef, writeRef} from '../stdlib'\nimport {filterChanged, noop} from '../blocks'\nimport {startPhaseTimer, stopPhaseTimer} from '../perf'\nimport {getDisplayName} from '../naming'\nimport {createLink, type Event} from '../event'\nimport type {Store, ThisStore} from './index.h'\nimport type {Subscriber} from '../index.h'\n\nexport function reset(storeInstance: ThisStore, ...events: Array<Event<any>>) {\n  for (const event of events)\n    on.call(this, storeInstance, event, () => storeInstance.defaultState)\n  return this\n}\nexport function getState(storeInstance: ThisStore) {\n  return readRef(storeInstance.plainState)\n}\nexport function off(storeInstance: ThisStore, event: Event<any>) {\n  const currentSubscription = storeInstance.subscribers.get(event)\n  if (currentSubscription === undefined) return\n  currentSubscription()\n  storeInstance.subscribers.delete(event)\n}\n\nexport function on(storeInstance: ThisStore, event: any, handler: Function) {\n  const from: Event<any> = event\n  const oldLink = storeInstance.subscribers.get(from)\n  if (oldLink) oldLink()\n  storeInstance.subscribers.set(\n    from,\n    createLink(from, {\n      scope: {handler, state: storeInstance.plainState, trigger: from},\n      child: [storeInstance],\n      //prettier-ignore\n      node: [\n        step.compute({\n          fn(newValue, {handler, state, trigger}) {\n            const result = handler(\n              readRef(state),\n              newValue,\n              getDisplayName(trigger),\n            )\n            if (result === undefined) return\n            return writeRef(state, result)\n          },\n        }),\n      ]\n    }),\n  )\n  return this\n}\nexport function observable(storeInstance: ThisStore) {\n  const result = {\n    subscribe(observer: Subscriber<any>) {\n      invariant(\n        typeof observer === 'object' && observer !== null,\n        'Expected the observer to be an object.',\n      )\n\n      function observeState(state) {\n        if (observer.next) {\n          observer.next(state)\n        }\n      }\n      return subscribe(storeInstance, observeState)\n    },\n  }\n  //$off\n  result[$$observable] = function() {\n    return this\n  }\n  return result\n}\nexport function watch(\n  storeInstance: ThisStore,\n  eventOrFn: Event<*> | Function,\n  fn?: Function,\n) {\n  const message = 'watch requires function handler'\n  switch (fn && eventOrFn?.kind) {\n    case 'store':\n    case 'event':\n    case 'effect':\n      invariant(typeof fn === 'function', message)\n      return eventOrFn.watch(payload =>\n        //$todo\n        fn(getState(storeInstance), payload, getDisplayName(eventOrFn)),\n      )\n    default:\n      invariant(typeof eventOrFn === 'function', message)\n      return subscribe(storeInstance, eventOrFn)\n  }\n}\nexport function subscribe(storeInstance: ThisStore, listener: Function) {\n  invariant(\n    typeof listener === 'function',\n    'Expected the listener to be a function',\n  )\n  let stopPhaseTimerMessage = 'Got initial error'\n  let lastCall = getState(storeInstance)\n\n  startPhaseTimer(storeInstance, 'subscribe')\n  try {\n    listener(lastCall)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  return createLink(storeInstance, {\n    node: [\n      noop,\n      step.run({\n        fn(args) {\n          let stopPhaseTimerMessage = null\n          startPhaseTimer(storeInstance, 'subscribe')\n          if (args === lastCall) {\n            stopPhaseTimer(stopPhaseTimerMessage)\n            return\n          }\n          lastCall = args\n          try {\n            listener(args)\n          } catch (err) {\n            console.error(err)\n            stopPhaseTimerMessage = 'Got error'\n          }\n          stopPhaseTimer(stopPhaseTimerMessage)\n        },\n      }),\n    ],\n  })\n}\nexport function dispatch(action: any) {\n  return action\n}\n\nexport function mapStore<A, B>(\n  store: Store<A>,\n  fn: (state: A, lastState?: B) => B,\n  firstState?: B,\n): Store<B> {\n  startPhaseTimer(store, 'map')\n  let lastResult\n  let stopPhaseTimerMessage = 'Got initial error'\n  try {\n    const storeState = store.getState()\n    if (storeState !== undefined) {\n      lastResult = fn(storeState, firstState)\n    }\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  const innerStore: Store<any> = this({\n    config: {name: '' + store.shortName + ' → *'},\n    currentState: lastResult,\n    parent: store.domainName,\n  })\n  createLink(store, {\n    child: [innerStore],\n    scope: {store, handler: fn, state: innerStore.stateRef},\n    node: [\n      step.compute({\n        fn(newValue, {state, store, handler}) {\n          startPhaseTimer(store, 'map')\n          let stopPhaseTimerMessage = 'Got error'\n          let result\n          try {\n            result = handler(newValue, readRef(state))\n            stopPhaseTimerMessage = null\n          } catch (err) {\n            console.error(err)\n          }\n          stopPhaseTimer(stopPhaseTimerMessage)\n          return result\n        },\n      }),\n      filterChanged,\n    ],\n  })\n  return innerStore\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport {launch} from '../kernel'\nimport {step, createGraph, Kind, createStateRef} from '../stdlib'\nimport {createEvent, forward} from '../event'\n\nimport type {Store, ThisStore} from './index.h'\nimport type {StoreConfigPart as ConfigPart} from '../config'\nimport {createName, type CompositeName} from '../compositeName'\nimport {thru} from '../thru'\nimport {\n  reset,\n  getState,\n  off,\n  on,\n  observable,\n  watch,\n  subscribe,\n  dispatch,\n  mapStore,\n} from './storeMethods'\n\nexport function storeFabric<State>(props: {\n  currentState: State,\n  config: ConfigPart,\n  parent?: CompositeName,\n  ...\n}): Store<State> {\n  const {currentState, config, parent} = props\n  const {name} = config\n  const plainState = createStateRef(currentState)\n  const currentId = name || plainState.id\n  const defaultState = currentState\n  const compositeName = createName(currentId, parent)\n\n  const updates: any = createEvent('update ' + currentId)\n  const storeInstance: ThisStore = {\n    graphite: createGraph({\n      scope: {state: plainState, oldState: currentState},\n      node: [\n        step.filter({\n          fn: upd => upd !== undefined,\n        }),\n        step.update({\n          store: plainState,\n        }),\n        step.filter({\n          fn(upd, scope) {\n            if (upd === scope.oldState) return false\n            scope.oldState = upd\n            return true\n          },\n        }),\n      ],\n    }),\n    kind: Kind.store,\n    id: plainState.id,\n    shortName: currentId,\n    domainName: parent,\n    defaultConfig: config,\n    defaultState,\n    plainState,\n    subscribers: new Map(),\n    compositeName,\n  }\n  const store: $Shape<Store<State>> = {\n    compositeName: storeInstance.compositeName,\n    graphite: storeInstance.graphite,\n    kind: Kind.store,\n    id: plainState.id,\n    shortName: currentId,\n    domainName: parent,\n    setState,\n    off: off.bind(null, storeInstance),\n    watch: watch.bind(null, storeInstance),\n    updates,\n    subscribe: subscribe.bind(null, storeInstance),\n    getState: getState.bind(null, storeInstance),\n    stateRef: plainState,\n  }\n  ;(store: any).defaultConfig = config\n  ;(store: any).reset = reset.bind(store, storeInstance)\n  ;(store: any).on = on.bind(store, storeInstance)\n  ;(store: any).defaultState = defaultState\n  ;(store: any).map = mapStore.bind(storeFabric, store)\n  ;(store: any).thru = thru.bind(store)\n  ;(store: any).dispatch = dispatch.bind(null)\n  //$off\n  store[$$observable] = observable.bind(null, storeInstance)\n  forward({\n    from: store,\n    to: updates,\n  })\n\n  function setState(value, reduce?: Function) {\n    const state = getState(storeInstance)\n    const newResult =\n      typeof reduce === 'function' ? reduce(state, value) : value\n\n    launch(store, newResult)\n  }\n\n  return store\n}\n","//@flow\n\nimport invariant from 'invariant'\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\nimport {type Config, type StoreConfigPart, normalizeConfig} from '../config'\n\nexport function createStore<State>(\n  state: State,\n  config: Config<StoreConfigPart> = {},\n): Store<State> {\n  invariant(\n    typeof state !== 'undefined',\n    \"createStore: First argument can't be undefined, use null instead.\",\n  )\n  const opts = normalizeConfig(config)\n  return storeFabric({\n    currentState: state,\n    config: opts,\n  })\n}\n","//@flow\n\nimport {is} from '../validate'\nimport {__DEBUG__} from 'effector/flags'\nimport type {Store} from './index.h'\nimport {createName} from '../compositeName'\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, store.domainName)\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  //$todo\n  store.compositeName.path = compositeName.path\n  //$todo\n  store.compositeName.shortName = compositeName.shortName\n  //$todo\n  store.compositeName.fullName = compositeName.fullName\n}\n\nexport function storeNaming<Obj: {[key: string]: Store<any> | Object, ...}>(\n  object: Obj,\n  parent?: Store<any>,\n) {\n  for (const storeName in object) {\n    const store: Store<any> = object[storeName]\n    if (!is.store(store)) {\n      console.warn(\n        'effector: Key \"%s\" must be store but instead received %s',\n        storeName,\n        store.kind || '\"' + typeof store + '\"',\n        store,\n      )\n      continue\n    }\n    if (parent) {\n      store.domainName = parent.compositeName || store.domainName\n    }\n    setStoreName(store, storeName)\n    if (store.defaultShape !== undefined) {\n      storeNaming(store.defaultShape, store)\n    }\n  }\n}\n","//@flow\nimport {\n  step,\n  nextBarrierID,\n  createStateRef,\n  readRef,\n  writeRef,\n  type StateRef,\n} from '../stdlib'\nimport {is} from '../validate'\nimport {unitObjectName} from '../naming'\nimport {createLink} from '../event'\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\ntype CombinationScope = {\n  key: any,\n  target: StateRef,\n  clone(value: any): any,\n  isFresh: StateRef,\n  ...\n}\n\nconst storeCombination = (obj: any, clone: Function, defaultState: any) => {\n  const node = [\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {target, key}: CombinationScope) => (\n        upd !== readRef(target)[key]\n      && upd !== undefined\n      ),\n    }),\n    step.tap({\n      fn(upd, {isFresh, target, clone}: CombinationScope) {\n        if (readRef(isFresh)) return\n        writeRef(target, clone(readRef(target)))\n        writeRef(isFresh, true)\n      },\n    }),\n    step.tap({\n      fn(upd, {target, key}: CombinationScope) {\n        readRef(target)[key] = upd\n      },\n    }),\n    step.barrier({barrierID: nextBarrierID()}),\n    step.compute({\n      fn(none, {isFresh, target}: CombinationScope) {\n        writeRef(isFresh, false)\n        return readRef(target)\n      },\n    }),\n  ]\n  const stateNew = clone(defaultState)\n  const store = storeFabric({\n    currentState: stateNew,\n    //TODO: add location\n    config: {name: unitObjectName(obj)},\n  })\n  const isFresh = createStateRef(false)\n  for (const key in obj) {\n    const child = obj[key]\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      continue\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    createLink(child, {\n      scope: {key, clone, target: store.stateRef, isFresh},\n      node,\n      child: [store],\n    })\n  }\n\n  ;(store: any).defaultShape = obj\n  ;(store: any).defaultState = defaultState\n  return store\n}\n\ndeclare export function createStoreObject<\n  State: $ReadOnlyArray<Store<any> | any>,\n>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function createStoreObject<\n  State: {-[key: string]: Store<any> | any, ...},\n>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\n//prettier-ignore\nexport function createStoreObject(obj: *, fn?: Function) {\n  const mergedStore = Array.isArray(obj)\n    ? storeCombination(\n      obj,\n      list => list.slice(),\n      [],\n    )\n    : storeCombination(\n      obj,\n      obj => Object.assign({}, obj),\n      {},\n    )\n  return fn\n    ? mergedStore.map(fn)\n    : mergedStore\n}\n//eslint-disable-next-line\ndeclare export function extract<\n  State: $ReadOnlyArray<Store<any> | any>,\n  NextState: $ReadOnlyArray<Store<any> | any>,\n>(\n  store: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $TupleMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function extract<\n  State: {-[key: string]: Store<any> | any, ...},\n  NextState: {-[key: string]: Store<any> | any, ...},\n>(\n  obj: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $ObjMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function extract(store: Store<any>, extractor: any => any) {\n  let result\n  if ('defaultShape' in store) result = extractor((store: any).defaultShape)\n  else result = extractor((store: any).defaultState)\n  return createStoreObject(result)\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {type Event, createEvent} from '../event'\n\ndeclare export function createApi<\n  S,\n  Obj: {-[name: string]: (store: S, e: any) => S, ...},\n>(\n  store: Store<S>,\n  setters: Obj,\n): $ObjMap<Obj, <E>(h: (store: S, e: E) => S) => Event<E>>\n\nexport function createApi(store: Store<any>, setters: {[string]: Function, ...}) {\n  const result = {}\n  for (const key in setters) {\n    const handler: any = setters[key]\n    const event = (result[key] = createEvent(key))\n    store.on(event, handler)\n  }\n  return result\n}\n","//@flow\nimport type {Event} from '../event'\nimport type {Effect} from '../effect'\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\nimport {is} from '../validate'\n\nexport function restoreObject<State: {+[key: string]: Store<any> | any, ...}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n> {\n  const result = {}\n  for (const key in obj) {\n    const value = obj[key]\n    if (is.store(value)) {\n      result[key] = value\n    } else {\n      result[key] = storeFabric({\n        currentState: value,\n        config: {name: key},\n      })\n    }\n  }\n  return result\n}\n\nexport function restoreEffect<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done> {\n  const store = storeFabric({\n    currentState: defaultState,\n    parent: event.domainName,\n    //TODO: add location\n    config: {name: event.shortName},\n  })\n  store.on(event.done, (_, {result}) => result)\n  return store\n}\n\nexport function restoreEvent<E>(event: Event<E>, defaultState: E): Store<E> {\n  const store = storeFabric({\n    currentState: defaultState,\n    parent: event.domainName,\n    //TODO: add location\n    config: {name: event.shortName},\n  })\n  store.on(event, (_, v) => v)\n  return store\n}\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function restore<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done>\ndeclare export function restore<E>(event: Event<E>, defaultState: E): Store<E>\ndeclare export function restore<State: {-[key: string]: Store<any> | any, ...}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n>\nexport function restore(obj: any, defaultState: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.event(obj)) {\n    return restoreEvent(obj, defaultState)\n  }\n  if (is.effect(obj)) {\n    return restoreEffect(obj, defaultState)\n  }\n  return restoreObject(obj)\n}\n","//@flow\n\nimport type {Store} from './index.h'\n\nexport function withProps<R, S, P>(\n  store: Store<S>,\n  handler: (store: S, props: P) => R,\n): (props: P) => R {\n  return (props: P) => handler(store.getState(), props)\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport {type Store, createStoreObject} from './store'\nimport {is} from './validate'\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function combine<R>(fn: () => R): Store<R>\ndeclare export function combine<A, R>(a: Store<A>, fn: (a: A) => R): Store<R>\ndeclare export function combine<A, B, R>(\n  a: Store<A>,\n  b: Store<B>,\n  fn: (a: A, b: B) => R,\n): Store<R>\ndeclare export function combine<A, B, C, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  fn: (a: A, b: B, c: C) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  fn: (a: A, b: B, c: C, d: D) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  fn: (a: A, b: B, c: C, d: D, e: E) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, K, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  k: Store<K>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) => R,\n): Store<R>\n\nexport function combine(...args: Array<Store<any>>): Store<any> {\n  invariant(args.length > 0, 'at least one argument required')\n  let handler\n  let stores\n  {\n    const rawHandler = args[args.length - 1]\n    if (typeof rawHandler === 'function') {\n      stores = args.slice(0, -1)\n      handler = rawHandler\n    } else {\n      stores = args\n    }\n  }\n\n  let structStoreShape\n\n  makeShape: {\n    if (stores.length === 1) {\n      const obj = stores[0]\n      /*\n      without edge case combine(Color, (Color) => '~')\n      */\n      if (!is.store(obj)) {\n        /*\n        case combine([R,G,B], ([R,G,B]) => '~')\n        case combine({R,G,B}, ({R,G,B}) => '~')\n\n        edge case combine([Color], ([Color]) => '~')\n        edge case combine({Color}, ({Color}) => '~')\n\n        edge case combine([R,G,B])\n        edge case combine({R,G,B})\n\n        edge case combine([Color])\n        edge case combine({Color})\n        */\n        structStoreShape = obj\n        break makeShape\n      }\n    }\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  //$off\n  return createStoreObject(structStoreShape, handler)\n}\n\nconst spreadArgs = fn => list => fn(...list)\n","//@flow\n/* eslint-disable no-nested-ternary */\nimport {is} from './validate'\nimport {eventFabric, createLink, forward} from './event'\nimport {storeFabric, createStoreObject} from './store'\nimport {noop} from './blocks'\nimport {\n  step,\n  type Graphite,\n  createStateRef,\n  readRef,\n  writeRef,\n  nextBarrierID,\n} from './stdlib'\n\nconst storeBy = (source, clock, fn, greedy, target) => {\n  createLink(clock, {\n    scope: {\n      state: source.stateRef,\n      fn,\n    },\n    child: [target],\n    node: [\n      //$off\n      !greedy && noop,\n      //$off\n      !greedy\n        && step.barrier({\n          barrierID: nextBarrierID(),\n          priority: 'sampler',\n        }),\n      step.compute({\n        fn: fn\n          ? (upd, {state, fn}) => fn(readRef(state), upd)\n          : (upd, {state}) => readRef(state),\n      }),\n    ].filter(Boolean),\n  })\n  return target\n}\n\nconst storeByEvent = (source: any, clock: any, fn: any, greedy, target) =>\n  storeBy(\n    source,\n    clock,\n    fn,\n    greedy,\n    target\n      || eventFabric({\n        name: source.shortName,\n        parent: source.domainName,\n      }),\n  )\n\nconst storeByStore = (source: any, clock: any, fn: any, greedy, target) => {\n  const sourceState = readRef(source.stateRef)\n  return storeBy(\n    source,\n    clock,\n    fn,\n    greedy,\n    target\n      || storeFabric({\n        currentState: fn\n          ? fn(sourceState, readRef(clock.stateRef))\n          : sourceState,\n        config: {name: source.shortName},\n        parent: source.domainName,\n      }),\n  )\n}\n\nconst eventByUnit = (source: any, clock: any, fn: any, greedy, target) => {\n  target =\n    target\n    || eventFabric({\n      name: source.shortName,\n      parent: source.domainName,\n    })\n  const hasSource = createStateRef(false)\n  const sourceState = createStateRef()\n  const clockState = createStateRef()\n\n  createLink(source, {\n    scope: {hasSource},\n    node: [\n      step.update({store: sourceState}),\n      step.tap({\n        fn(upd, {hasSource}) {\n          writeRef(hasSource, true)\n        },\n      }),\n    ],\n  })\n\n  createLink(clock, {\n    scope: {sourceState, clockState, hasSource, fn},\n    child: [target],\n    node: [\n      step.update({store: clockState}),\n      step.filter({\n        fn: (upd, {hasSource}) => readRef(hasSource),\n      }),\n      //$off\n      !greedy\n        && step.barrier({\n          barrierID: nextBarrierID(),\n          priority: 'sampler',\n        }),\n      step.compute({\n        fn: fn\n          ? (upd, {sourceState, clockState, fn}) =>\n            fn(readRef(sourceState), readRef(clockState))\n          : (upd, {sourceState}) => readRef(sourceState),\n      }),\n    ].filter(Boolean),\n  })\n  return target\n}\n\nexport function sample(\n  source: any,\n  clock: Graphite,\n  fn?: boolean | ((source: any, clock: any) => any),\n  greedy: boolean = false,\n): any {\n  let target\n  //config case\n  if (clock === undefined && 'source' in source) {\n    clock = source.clock || source.sampler\n    fn = source.fn\n    greedy = source.greedy\n    //optional target accepted only from config\n    target = source.target\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  const sourceNorm = unitOrCombine(source)\n  const clockNorm = unitOrCombine(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = undefined\n  }\n  //prettier-ignore\n  const combinator =\n    is.store(sourceNorm)\n      ? is.store(clockNorm)\n        ? storeByStore\n        : storeByEvent\n      : eventByUnit\n  return combinator(sourceNorm, clockNorm, fn, greedy, target)\n}\n\n//prettier-ignore\nconst unitOrCombine = (obj: any) => is.unit(obj)\n  ? obj\n  : createStoreObject(obj)\n","//@flow\n\nimport warning from 'warning'\nimport type {Effect} from './index.h'\nimport {Kind, step} from '../stdlib'\nimport {upsertLaunch} from '../kernel'\nimport {eventFabric, type Event} from '../event'\nimport {createStore} from '../store'\nimport type {EffectConfigPart} from '../config'\nimport type {CompositeName} from '../compositeName'\n\nfunction OnResolve(result) {\n  const {event, params, handler} = this\n  //prettier-ignore\n  upsertLaunch(event, {\n    handler,\n    toHandler: result,\n    result: {\n      params,\n      result,\n    },\n  })\n}\nfunction OnReject(error) {\n  const {event, params, handler} = this\n  //prettier-ignore\n  upsertLaunch(event, {\n    handler,\n    toHandler: error,\n    result: {\n      params,\n      error,\n    },\n  })\n}\n\nfunction Def() {\n  /*::\n  this.rs = result => {}\n  this.rj = error => {}\n  */\n  const req = new Promise((rs, rj) => {\n    this.rs = rs\n    this.rj = rj\n  })\n  //$off\n  req.anyway = () => {\n    warning(false, '.anyway is deprecated, use .finally')\n    return req.then(() => {}, () => {})\n  }\n  this.req = req\n}\n\nconst notifyHandler = step.run({\n  fn({handler, toHandler, result}, scope) {\n    handler(toHandler)\n    return result\n  },\n})\nexport function effectFabric<Payload, Done>({\n  name,\n  domainName,\n  parent,\n  config,\n}: {\n  name?: string,\n  domainName: string,\n  parent?: CompositeName,\n  config: EffectConfigPart<Payload, Done>,\n  ...\n}): Effect<Payload, Done, *> {\n  const {handler} = config\n\n  //$off\n  const instance: Effect<Payload, Done, any> = eventFabric({\n    name,\n    parent,\n    config,\n  })\n\n  const eventCreate = instance.create\n  const done: Event<{|\n    params: Payload,\n    result: Done\n  |}> = eventFabric({\n    name: '' + instance.shortName + ' done',\n    parent,\n    config,\n  })\n  const fail: Event<{|\n    params: Payload,\n    error: *\n  |}> = eventFabric({\n    name: '' + instance.shortName + ' fail',\n    parent,\n    config,\n  })\n  done.graphite.seq.push(notifyHandler)\n  fail.graphite.seq.push(notifyHandler)\n  //eslint-disable-next-line no-unused-vars\n  let thunk: Function = handler || defaultThunk.bind(instance)\n\n  instance.done = done\n  instance.fail = fail\n  ;(instance: any).use = fn => {\n    thunk = fn\n    return instance\n  }\n  const getCurrent = (): any => thunk\n  ;(instance: any).use.getCurrent = getCurrent\n  ;(instance: any).kind = Kind.effect\n  //assume that fresh event has empty scope\n  ;(instance: any).graphite.scope = {done, fail, getHandler: getCurrent}\n  instance.graphite.seq.push(\n    step.compute({\n      fn(params, scope) {\n        if (typeof params === 'object' && params !== null) {\n          if ('ɔ' in params) return params.ɔ\n        }\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn({params, req}, {getHandler, done, fail}) {\n        runEffect(\n          getHandler(),\n          params,\n          OnResolve.bind({event: done, params, handler: req.rs}),\n          OnReject.bind({event: fail, params, handler: req.rj}),\n        )\n        return params\n      },\n    }),\n  )\n  ;(instance: any).create = (params: Payload, fullName, args) => {\n    const req = new Def()\n    eventCreate({ɔ: {params, req}}, instance.getType(), args)\n    return req.req\n  }\n  /* terser will minify true and false to 1 and 0,\n    thereby we need to define true as Boolean(1)\n    and false as Boolean(0) */\n  instance.pending = createStore(Boolean(0))\n    .on(instance, () => Boolean(1))\n    .reset(done)\n    .reset(fail)\n  return instance\n}\nfunction runEffect(handler, params, onResolve, onReject) {\n  let failedSync = false\n  let syncError\n  let rawResult\n  try {\n    rawResult = handler(params)\n  } catch (err) {\n    failedSync = true\n    syncError = err\n  }\n  if (failedSync) {\n    onReject(syncError)\n    return\n  }\n  if (typeof rawResult === 'object' && rawResult !== null) {\n    if (typeof rawResult.then === 'function') {\n      rawResult.then(onResolve, onReject)\n      return\n    }\n  }\n  onResolve(rawResult)\n}\n//eslint-disable-next-line no-unused-vars\nfunction defaultThunk(value) {\n  warning(false, 'no thunk used in %s', this.getType())\n  return Promise.resolve()\n}\n","//@flow\n\nimport {effectFabric} from './effectFabric'\nimport {\n  normalizeEventConfig,\n  type EffectConfigPart,\n  type Config,\n} from '../config'\nimport type {Effect} from './index.h'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig?: string | EffectConfigPart<Payload, Done>,\n  opts?: Config<EffectConfigPart<Payload, Done>>,\n): Effect<Payload, Done, *> {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return effectFabric({\n    name,\n    domainName: '',\n    config,\n  })\n}\n","//@flow\n\nimport {domainFabric} from './domainFabric'\nimport {normalizeEventConfig, type Config, type DomainConfigPart} from '../config'\n\nexport function createDomain(\n  nameOrConfig?: string | DomainConfigPart,\n  opts?: Config<DomainConfigPart> = {},\n) {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return domainFabric({\n    name: name === undefined ? '' : name,\n    config,\n  })\n}\n","//@flow\n\nimport {stringRefcount, Kind} from '../stdlib'\nimport {type Store, storeFabric} from '../store'\nimport {\n  normalizeConfig,\n  type Config,\n  type EffectConfigPart,\n  type EventConfigPart,\n  type StoreConfigPart,\n} from '../config'\nimport {type Event, eventFabric} from '../event'\nimport {type Effect, effectFabric} from '../effect'\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {DomainConfigPart} from '../config'\nimport {createName, type CompositeName} from '../compositeName'\nimport {DomainHistory, domainHooks} from './hook'\n\nconst nextID = stringRefcount()\n\nexport function domainFabric({\n  name: nameRaw,\n  config = {},\n  parent,\n  parentHooks,\n}: {\n  name?: string,\n  config?: DomainConfigPart,\n  parent?: CompositeName,\n  parentHooks?: DomainHooks,\n  ...\n}): Domain {\n  const id = nextID()\n  const name = nameRaw || ''\n  const compositeName = createName(name, parent)\n  const history = new DomainHistory()\n  const hooks = domainHooks(history, compositeName, parentHooks)\n\n  return {\n    compositeName,\n    id,\n    defaultConfig: config,\n    getType() {\n      return compositeName.fullName\n    },\n    onCreateEvent(hook: (newEvent: Event<any>) => any) {\n      history.events.forEach(hook)\n      return hooks.event.watch(hook)\n    },\n    onCreateEffect(hook: (newEffect: Effect<any, any, any>) => any) {\n      history.effects.forEach(hook)\n      return hooks.effect.watch(hook)\n    },\n    onCreateStore(hook: (newStore: Store<any>) => any) {\n      history.storages.forEach(hook)\n      return hooks.store.watch(hook)\n    },\n    onCreateDomain(hook: (newDomain: Domain) => any) {\n      history.domains.forEach(hook)\n      return hooks.domain.watch(hook)\n    },\n    event<Payload>(\n      name?: string,\n      config: Config<EventConfigPart> = {},\n    ): Event<Payload> {\n      const opts = normalizeConfig(config)\n      const result = eventFabric({\n        name,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.event(result)\n      return result\n    },\n    effect<Params, Done, Fail>(\n      name?: string,\n      config: Config<EffectConfigPart<Params, Done>> = {},\n    ): Effect<Params, Done, Fail> {\n      const opts = normalizeConfig(config)\n      const result = effectFabric({\n        name,\n        domainName: compositeName.fullName,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.effect(result)\n      return result\n    },\n    domain(name?: string, config: Config<DomainConfigPart> = {}) {\n      const opts = normalizeConfig(config)\n      const result = domainFabric({\n        name,\n        parent: compositeName,\n        parentHooks: hooks,\n        config: opts,\n      })\n      hooks.domain(result)\n      return result\n    },\n    store<T>(state: T, config: Config<StoreConfigPart> = {}): Store<T> {\n      const opts = normalizeConfig(config)\n      const result = storeFabric({\n        currentState: state,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.store(result)\n      return result\n    },\n    kind: Kind.domain,\n  }\n}\n","//@flow\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {Store} from '../store'\nimport {type Event, eventFabric} from '../event'\nimport type {Effect} from '../effect'\nimport type {CompositeName} from '../compositeName'\nexport class DomainHistory {\n  /*::;+*/ events: Set<Event<any>> = new Set()\n  /*::;+*/ effects: Set<Effect<any, any, any>> = new Set()\n  /*::;+*/ storages: Set<Store<any>> = new Set()\n  /*::;+*/ domains: Set<Domain> = new Set()\n}\n\nexport function domainHooks(\n  history: DomainHistory,\n  compositeName: CompositeName,\n  parentHooks?: DomainHooks,\n) {\n  let hooks: {|\n    domain: Event<Domain>,\n    effect: Event<Effect<any, any, any>>,\n    event: Event<Event<any>>,\n    store: Event<any>,\n  |}\n  if (parentHooks) {\n    hooks = childDomainHooks(parentHooks)\n  } else {\n    hooks = singleDomainHooks(compositeName)\n  }\n  hooks.domain.watch(domain => {\n    history.domains.add(domain)\n  })\n  hooks.event.watch(event => {\n    history.events.add(event)\n  })\n  hooks.store.watch(store => {\n    history.storages.add(store)\n  })\n  hooks.effect.watch(effect => {\n    history.effects.add(effect)\n  })\n  return hooks\n}\n\nconst singleDomainHooks = (compositeName: CompositeName) => {\n  const event: Event<Event<any>> = eventFabric({\n    name: `${compositeName.fullName} event hook`,\n    parent: compositeName,\n  })\n  const effect: Event<Effect<any, any, any>> = eventFabric({\n    name: `${compositeName.fullName} effect hook`,\n    parent: compositeName,\n  })\n  const store: Event<Store<any>> = eventFabric({\n    name: `${compositeName.fullName} store hook`,\n    parent: compositeName,\n  })\n  const domain: Event<Domain> = eventFabric({\n    parent: compositeName,\n  })\n  return {event, effect, store, domain}\n}\n\nconst childDomainHooks = (parentHooks: DomainHooks) => {\n  const event: Event<Event<any>> = parentHooks.event.prepend(_ => _)\n  const effect: Event<Effect<any, any, any>> = parentHooks.effect.prepend(\n    _ => _,\n  )\n  const store: Event<Store<any>> = parentHooks.store.prepend(_ => _)\n  const domain: Event<Domain> = parentHooks.domain.prepend(_ => _)\n  return {event, effect, store, domain}\n}\n","//@flow\n\nexport const __DEBUG__ = false\nexport const __DEV__ = process.env.NODE_ENV !== 'production'\nexport const __CANARY__ = false\n\nexport {version} from '../../packages/effector/package.json'\n","//@flow\n/* eslint-disable */\nimport {__DEV__} from 'effector/flags'\n\nexport default (__DEV__\n  ? function invariant(condition: any, format: string, ...args: any) {\n      if (!condition) {\n        const error = Error()\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(error, invariant)\n        }\n        error.name = 'Invariant Violation'\n        let argIndex = 0\n        error.message = format.replace(/%s/g, () => args[argIndex++])\n        throw error\n      }\n    }\n  : function invariant(condition: any /*::, format: string, ...args: any*/) {\n      if (!condition) {\n        throw Error('Minified exception occurred')\n      }\n    })\n","//@flow\n\nimport type {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const stringRefcount = (): (() => string) => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n","//@flow\nimport type {\n  StateRef,\n  NodeMeta,\n  Update,\n  Run,\n  Tap,\n  Filter,\n  Emit,\n  Compute,\n  Barrier,\n  ID,\n} from './index.h'\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\n\nconst cmd = (type: any, data: any): any => ({\n  id: nextID(),\n  type,\n  group: 'cmd',\n  data,\n})\n\nexport const step: {|\n  barrier(data: {|\n    +barrierID: ID,\n    +priority?: 'barrier' | 'sampler',\n    meta?: NodeMeta,\n  |}): Barrier,\n  emit(data: {|\n    fullName: string,\n    meta?: NodeMeta,\n  |}): Emit,\n  compute(data: {|\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  |}): Compute,\n  filter(data: {|\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  |}): Filter,\n  run(data: {\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  }): Run,\n  tap(data: {\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  }): Tap,\n  update(data: {|\n    store: StateRef,\n    meta?: NodeMeta,\n  |}): Update,\n|} = {\n  barrier: ({barrierID, priority = 'barrier'}) =>\n    cmd('barrier', {\n      barrierID,\n      priority,\n    }),\n  compute: cmd.bind(null, 'compute'),\n  emit: cmd.bind(null, 'emit'),\n  filter: cmd.bind(null, 'filter'),\n  run: cmd.bind(null, 'run'),\n  tap: cmd.bind(null, 'tap'),\n  update: cmd.bind(null, 'update'),\n}\n","//@flow\nimport type {StateRef} from './index.h'\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextID(),\n  current,\n})\n\nexport const readRef = ({current}: StateRef | {current: any, ...}) => current\nexport const writeRef = (ref: StateRef | {current: any, ...}, value: any) =>\n  (ref.current = value)\n","//@flow\n\nimport {stringRefcount} from './refcount'\nexport const nextBarrierID = stringRefcount()\n","// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n//@flow\n/* eslint-disable */\n\nexport type PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\nexport const getPriority = (t: PriorityTag) => {\n  switch(t) {\n    case 'child': return 0\n    case 'pure': return 1\n    case 'barrier': return 2\n    case 'sampler': return 3\n    case 'effect': return 4\n    default: return -1\n  }\n}","//@flow\n\nimport type {\n  Graph,\n  Graphite,\n  StateRef,\n  Cmd,\n  Emit,\n  Run,\n  Update,\n  Filter,\n  Compute,\n  Barrier,\n  Tap,\n} from '../stdlib'\nimport {getGraph, writeRef, readRef} from '../stdlib'\n\nimport {getPriority, type PriorityTag} from './getPriority'\n\nclass Stack {\n  /*::\n  value: {current: any}\n  parent: Stack | null\n  */\n  constructor(value: any, parent: Stack | null) {\n    this.value = {current: value}\n    this.parent = parent\n  }\n}\n\ntype Layer = {|\n  +step: Graph,\n  +firstIndex: number,\n  +scope: Stack,\n  +resetStop: boolean,\n  +type: PriorityTag,\n  +id: number,\n|}\n\nexport class Leftist {\n  /*::\n  left: leftist\n  right: leftist\n  value: Layer\n  rank: number\n  */\n  constructor(value: Layer, rank: number, left: leftist, right: leftist) {\n    this.value = value\n    this.rank = rank\n    this.left = left\n    this.right = right\n  }\n}\nexport type leftist = null | Leftist\nconst insert = (x: Layer, t: leftist): leftist =>\n  merge(new Leftist(x, 1, null, null), t)\n\nconst deleteMin = (param: leftist): leftist => {\n  if (param) {\n    return merge(param.left, param.right)\n  }\n  return null\n}\nconst merge = (_t1: leftist, _t2: leftist): leftist => {\n  let t2\n  let t1\n  let k1\n  let l\n  let merged\n  let rank_left\n  let rank_right\n  while (true) {\n    t2 = _t2\n    t1 = _t1\n    if (!t1) return t2\n    if (!t2) return t1\n    k1 = t1.value\n    l = t1.left\n    if (layerComparator(k1, t2.value)) {\n      _t2 = t1\n      _t1 = t2\n      continue\n    }\n    merged = merge(t1.right, t2)\n    rank_left = l?.rank || 0\n    rank_right = merged?.rank || 0\n    if (rank_left >= rank_right) {\n      return new Leftist(k1, rank_right + 1, l, merged)\n    }\n    return new Leftist(k1, rank_left + 1, merged, l)\n  }\n  /*::return _t1*/\n}\nclass Local {\n  /*::\n  isChanged: boolean\n  isFailed: boolean\n  scope: {[key: string]: any, ...}\n  */\n  constructor(scope: {[key: string]: any, ...}) {\n    this.isChanged = true\n    this.isFailed = false\n    this.scope = scope\n  }\n}\nconst layerComparator = (a: Layer, b: Layer) => {\n  if (a.type === b.type) return a.id > b.id\n  return getPriority(a.type) > getPriority(b.type)\n}\nlet layerID = 0\nlet heap: leftist = null\nconst barriers = new Set()\nconst pushHeap = (opts: Layer) => {\n  heap = insert(opts, heap)\n}\nconst runGraph = ({step: graph, firstIndex, scope, resetStop}: Layer, meta) => {\n  const local = new Local(graph.scope)\n  for (\n    let stepn = firstIndex;\n    stepn < graph.seq.length && !meta.stop;\n    stepn++\n  ) {\n    const step = graph.seq[stepn]\n    if (stepn === firstIndex) {\n      if (step.type === 'barrier') {\n        barriers.delete(step.data.barrierID)\n      }\n    } else {\n      switch (step.type) {\n        case 'run':\n          pushHeap({\n            step: graph,\n            firstIndex: stepn,\n            scope,\n            resetStop: false,\n            type: 'effect',\n            id: ++layerID,\n          })\n          return\n        case 'barrier': {\n          const id = step.data.barrierID\n          if (!barriers.has(id)) {\n            barriers.add(id)\n            pushHeap({\n              step: graph,\n              firstIndex: stepn,\n              scope,\n              resetStop: false,\n              type: step.data.priority,\n              id: ++layerID,\n            })\n          }\n          return\n        }\n      }\n    }\n    const cmd = command[step.type]\n    //$todo\n    cmd(local, step.data, scope.value)\n    meta.stop = local.isFailed || !local.isChanged\n  }\n  if (!meta.stop) {\n    for (let stepn = 0; stepn < graph.next.length; stepn++) {\n      /**\n       * copy head of scope stack to feel free\n       * to override it during seq execution\n       */\n      const subscope = new Stack(readRef(scope.value), scope)\n      pushHeap({\n        step: graph.next[stepn],\n        firstIndex: 0,\n        scope: subscope,\n        resetStop: true,\n        type: 'child',\n        id: ++layerID,\n      })\n    }\n  }\n  if (resetStop) {\n    meta.stop = false\n  }\n}\n\nlet alreadyStarted = false\n\nconst addSingleBranch = (unit: Graphite, payload: any) => {\n  pushHeap({\n    step: getGraph(unit),\n    firstIndex: 0,\n    scope: new Stack(payload, null),\n    resetStop: false,\n    type: 'pure',\n    id: ++layerID,\n  })\n}\n\nconst exec = () => {\n  const lastStartedState = alreadyStarted\n  alreadyStarted = true\n  const meta = {\n    stop: false,\n  }\n  let value\n  while (heap) {\n    value = heap.value\n    heap = deleteMin(heap)\n    runGraph(value, meta)\n  }\n  alreadyStarted = lastStartedState\n}\nexport const launch = (unit: Graphite, payload: any) => {\n  addSingleBranch(unit, payload)\n  exec()\n}\nexport const upsertLaunch = (unit: Graphite, payload: any) => {\n  addSingleBranch(unit, payload)\n  if (alreadyStarted) return\n  exec()\n}\nconst command = {\n  barrier(local, step: $PropertyType<Barrier, 'data'>, val: StateRef) {\n    local.isFailed = false\n    local.isChanged = true\n  },\n  emit(local, step: $PropertyType<Emit, 'data'>, val: StateRef) {},\n  filter(local, step: $PropertyType<Filter, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    /**\n     * .isFailed assignment is not needed because in such case\n     * runCtx.result will be null\n     * thereby successfully forcing that branch to stop\n     */\n    local.isChanged = !!runCtx.result\n  },\n  run(local, step: $PropertyType<Run, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n    writeRef(val, runCtx.result)\n  },\n  update(local, step: $PropertyType<Update, 'data'>, val: StateRef) {\n    writeRef(step.store, readRef(val))\n  },\n  compute(local, step: $PropertyType<Compute, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n    writeRef(val, runCtx.result)\n  },\n  tap(local, step: $PropertyType<Tap, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n  },\n}\nconst tryRun = ({fn, arg, val}: any) => {\n  const result = {\n    err: false,\n    result: null,\n  }\n  try {\n    result.result = fn(arg, val)\n  } catch (err) {\n    console.error(err)\n    result.err = true\n  }\n  return result\n}\n","//@flow\n\nimport {step, readRef} from './stdlib'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== readRef(state)\n    && data !== undefined\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n","//@flow\nimport {__DEV__} from 'effector/flags'\n\nexport default (__DEV__\n  ? (condition: any, format: string, ...args: any) => {\n    if (!condition) {\n      console.error('Warning: ' + format, ...args)\n    }\n  }\n  : (/*::condition: any, format: string, ...args: any*/) => {})\n","//@flow\n\nimport {Kind, type kind} from '../stdlib'\n\nexport const unit = (obj: mixed) =>\n  (typeof obj === 'function' || (typeof obj === 'object' && obj !== null))\n  //$off\n  && 'kind' in obj\n\n//$off\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(Kind.store)\nexport const event = is(Kind.event)\nexport const effect = is(Kind.effect)\nexport const domain = is(Kind.domain)\n","//@flow\nimport {type Graphite, type Cmd, getGraph, createGraph} from '../stdlib'\nimport type {Subscription} from '../index.h'\nimport {createWatcher} from '../watcher'\n\nexport const createLink = (\n  from: Graphite,\n  opts: {|\n    +node: Array<Cmd>,\n    +child?: Array<Graphite>,\n    scope?: {[name: string]: any, ...},\n    meta?: {[name: string]: any, ...},\n  |},\n) =>\n  forward({\n    from,\n    to: createGraph(opts),\n  })\n\nexport const forward = (opts: {|\n  from: Graphite,\n  to: Graphite\n|}): Subscription => {\n  const from = getGraph(opts.from)\n  const to = getGraph(opts.to)\n  from.next.push(to)\n  //TODO push parent to .from field\n  // to.from.push(from)\n  return createWatcher({\n    child: to,\n    parent: from,\n  })\n}\n"],"names":["createGraph","node","child","from","scope","meta","map","getGraph","seq","next","getDisplayName","unit","compositeName","fullName","domainName","id","unitObjectName","objOrArr","i","arr","Object","values","max","unitObjectMaxNames","maxLength","length","name","comma","is","toString","Name","shortName","path","createName","parent","undefined","concat","thru","fn","this","disposer","indexOf","splice","noopIndexOf","noopSplice","eventFabric","nameRaw","config","nextID","graphite","step","emit","instance","payload","args","create","getType","launch","kind","Kind","$$observable","watch","event","watcher","createLink","trigger","handler","noop","run","bind","mapped","compute","filter","upd","result","prepend","contramapped","newValue","subscribe","observer","defaultConfig","normalizeConfig","message","warning","ɔ","newConfig","assign","normalizeEventConfig","nameOrConfig","opts","createEvent","fromObservable","observable","invariant","observableItem","clearNode","error","complete","startPhaseTimer","stopPhaseTimer","getState","storeInstance","readRef","plainState","off","currentSubscription","subscribers","get","delete","on","oldLink","set","state","writeRef","eventOrFn","listener","stopPhaseTimerMessage","lastCall","err","console","storeFabric","props","currentState","createStateRef","currentId","defaultState","updates","oldState","update","store","Map","setState","value","reduce","newResult","stateRef","reset","events","call","firstState","lastResult","storeState","innerStore","filterChanged","dispatch","action","forward","to","createStore","setStoreName","rawName","createStoreObject","obj","mergedStore","Array","isArray","storeCombination","list","slice","extract","extractor","defaultShape","createApi","setters","key","restoreObject","restoreEffect","done","_","restoreEvent","v","restore","withProps","combine","stores","structStoreShape","rawHandler","makeShape","spreadArgs","sample","source","clock","greedy","target","sampler","sourceNorm","unitOrCombine","clockNorm","storeByStore","storeByEvent","eventByUnit","Def","req","Promise","rs","rj","anyway","then","effectFabric","eventCreate","fail","push","notifyHandler","thunk","resolve","use","getCurrent","getHandler","params","data","onResolve","onReject","syncError","rawResult","failedSync","runEffect","upsertLaunch","toHandler","pending","Boolean","createEffect","createDomain","domainFabric","parentHooks","history","DomainHistory","hooks","childDomainHooks","singleDomainHooks","domain","domains","add","storages","effect","effects","domainHooks","onCreateEvent","hook","forEach","onCreateEffect","onCreateStore","onCreateDomain","__DEV__","process","env","NODE_ENV","condition","format","Error","captureStackTrace","argIndex","replace","stringRefcount","cmd","type","group","barrier","barrierID","priority","tap","deep","graph","index","current","ref","nextBarrierID","getPriority","t","Stack","constructor","Leftist","rank","left","right","deleteMin","param","merge","_t1","_t2","t2","t1","k1","l","merged","rank_left","rank_right","layerComparator","Local","isChanged","isFailed","a","b","layerID","heap","barriers","Set","pushHeap","x","insert","runGraph","firstIndex","resetStop","local","stepn","stop","has","command","subscope","alreadyStarted","addSingleBranch","exec","lastStartedState","val","runCtx","tryRun","arg","n","unsubscribe","createWatcher","currentPhase","currentPhaseStore","effectorEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","formatMarkName","markName","formatLabel","label","getStoreLabel","storeName","phase","getStoreMarkName","debugID","clearPendingPhaseMeasurement","componentName","clearStoreMark","beginStoreMark","formattedMarkName","formattedLabel","endMark","endStoreMark","clone","isFresh","none","stateNew","storeBy","sourceState","hasSource","clockState"],"mappings":"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"}