{"version":3,"file":"effector.cjs.js","sources":["node_modules/effector/stdlib/graph.js","node_modules/effector/naming.js","node_modules/effector/compositeName.js","node_modules/effector/thru.js","node_modules/effector/watcher/watcher.js","node_modules/effector/event/eventFabric.js","node_modules/effector/config.js","node_modules/effector/event/createEvent.js","node_modules/effector/perf/perf.js","node_modules/effector/store/storeMethods.js","node_modules/effector/store/storeFabric.js","node_modules/effector/store/createStore.js","node_modules/effector/store/createStoreObject.js","node_modules/effector/store/restore.js","node_modules/effector/combine.js","node_modules/effector/effect/effectFabric.js","node_modules/effector/flags.prod.js","node_modules/effector/validate/invariant.js","node_modules/effector/stdlib/kind.js","node_modules/effector/stdlib/refcount.js","node_modules/effector/stdlib/typedef.js","node_modules/effector/stdlib/stateref.js","node_modules/effector/stdlib/commonRefcount.js","node_modules/effector/kernel/getPriority.js","node_modules/effector/kernel/kernel.js","node_modules/effector/blocks.js","node_modules/effector/validate/warning.js","node_modules/effector/validate/is.js","node_modules/effector/event/forward.js","node_modules/effector/sample.js","node_modules/effector/domain/hook.js","node_modules/effector/domain/domainFabric.js","node_modules/effector/store/createApi.js","node_modules/effector/domain/createDomain.js","node_modules/effector/effect/createEffect.js","node_modules/effector/event/fromObservable.js","node_modules/effector/store/setStoreName.js","node_modules/effector/store/staticMethods.js"],"sourcesContent":["//@flow\n\nimport type {Graph, Graphite, Cmd} from './index.h'\n\nexport function createGraph({\n  node,\n  child = [],\n  from = [],\n  scope = {},\n  meta = {},\n}: {\n  +node: Array<Cmd>,\n  +child?: Array<Graphite>,\n  +from?: Array<Graphite>,\n  scope?: {[name: string]: any, ...},\n  meta?: {[name: string]: any, ...},\n  ...\n}): Graph {\n  return {\n    from: from.map(getGraph),\n    seq: node,\n    next: child.map(getGraph),\n    meta,\n    scope,\n  }\n}\nexport const clearNode = (\n  graphite: Graphite,\n  {deep}: {\n    deep?: boolean,\n    ...\n  } = {},\n) => {\n  const graph = getGraph(graphite)\n  if (deep) {\n    graph.next.forEach(node => clearNode(node, {deep}))\n  }\n  graph.from.forEach(node => {\n    const index = node.next.indexOf(graph)\n    if (index === -1) return\n    node.next.splice(index, 1)\n  })\n  graph.from.length = 0\n  graph.next.length = 0\n  graph.seq.length = 0\n  //$off\n  graph.scope = null\n}\n\nexport const getGraph = (graph: Graphite): Graph =>\n  (graph: any).graphite || graph\n\nexport const traverse = (\n  graphite: Graphite,\n  {ctx, pre, post}: {ctx: any, pre: Function, post: Function, ...},\n) => {\n  const visited = new Set()\n  const stack = []\n  const walk = (step, layer) => {\n    if (visited.has(step)) return\n    stack.push(step)\n    visited.add(step)\n    pre(step, ctx, stack, layer)\n    const steps = step.next\n    for (let i = 0; i < steps.length; i++) {\n      walk(steps[i], steps)\n    }\n    stack.pop()\n    post(step, ctx, stack, layer)\n  }\n  const graph = getGraph(graphite)\n  walk(graph, [graph])\n  visited.clear()\n  return ctx\n}\n","//@flow\n\nimport type {CompositeName} from './compositeName'\nimport {is} from './validate'\nimport type {Store} from './store'\nimport type {Event} from './event'\nimport type {Effect} from './effect'\n\nexport function getDisplayName(unit: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (unit.compositeName) {\n    return unit.compositeName.fullName\n  }\n  if (unit.domainName) {\n    return unit.domainName.fullName\n  }\n  return unit.id\n}\n\nconst unitObjectMaxNames = 25\n\nexport function unitObjectName(\n  objOrArr:\n    | $ReadOnlyArray<Store<any> | Event<any> | Effect<any, any, any> | any>\n    | {\n        [key: string]: Store<any> | Event<any> | Effect<any, any, any> | any,\n        ...\n      },\n) {\n  let i = 0\n  const arr: Array<any> = Object.values(objOrArr)\n  const max = unitObjectMaxNames - 1\n  const maxLength = arr.length - 1\n  let name = 'combine('\n  for (const unit of arr) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    if (is.store(unit) || is.event(unit) || is.effect(unit)) {\n      name += getDisplayName(unit) + comma\n    } else {\n      name += unit.toString() + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n","//@flow\n\nexport type CompositeName = {|\n  +shortName: string,\n  +fullName: string,\n  +path: Array<string>,\n|}\n\nfunction Name(shortName: string, fullName: string, path: Array<string>) {\n  this.shortName = shortName\n  this.fullName = fullName\n  this.path = path\n}\n\nexport function createName(name: string, parent?: CompositeName) {\n  let path\n  let fullName\n  const shortName = name\n  if (parent === undefined) {\n    if (name.length === 0) {\n      path = ([]: string[])\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    if (name.length === 0) {\n      path = parent.path\n      fullName = parent.fullName\n    } else {\n      path = parent.path.concat([name])\n      if (parent.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + parent.fullName + '/' + name\n      }\n    }\n  }\n  return new Name(shortName, fullName, path)\n}\n","//@flow\n\nexport function thru(fn: Function) {\n  return fn(this)\n}\n","//@flow\n\nimport type {TypeDef, Graph} from '../stdlib'\nimport type {Watcher} from './index.h'\n\nconst noopIndexOf = () => -1\n//eslint-disable-next-line no-unused-vars\nconst noopSplice = (i: number, n: number) => []\n\nfunction disposer() {\n  const i = this.indexOf()\n  if (i === -1) return\n  this.splice(i, 1)\n  this.indexOf = noopIndexOf\n  this.splice = noopSplice\n}\n\nexport const createWatcher = (opts: {|child: Graph, parent: Graph|}): Watcher => {\n  const subscribers = opts.parent.next\n  const instance = {\n    indexOf: subscribers.indexOf.bind(subscribers, opts.child),\n    splice: subscribers.splice.bind(subscribers),\n  }\n  const result = disposer.bind(instance)\n  result.unsubscribe = disposer.bind(instance)\n  return (result: $todo)\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport {step, Kind, stringRefcount, createGraph, type Unit} from '../stdlib'\nimport type {Effect} from '../effect'\nimport {launch} from '../kernel'\nimport {noop} from '../blocks'\n\nimport {getDisplayName} from '../naming'\nimport type {Subscription} from '../index.h'\nimport type {EventConfigPart} from '../config'\nimport type {Event} from './index.h'\nimport {type CompositeName, createName} from '../compositeName'\nimport {thru} from '../thru'\nimport {createLink} from './forward'\n\nconst nextID = stringRefcount()\n\nexport function eventFabric<Payload>({\n  name: nameRaw,\n  parent,\n  config = {},\n}: {\n  name?: string,\n  parent?: CompositeName,\n  config?: EventConfigPart,\n  ...\n}): Event<Payload> {\n  const id = nextID()\n  const name = nameRaw || id\n  const compositeName = createName(name, parent)\n  const fullName = compositeName.fullName\n  const graphite = createGraph({\n    node: [\n      step.emit({\n        fullName,\n      }),\n    ],\n  })\n\n  //$off\n  const instance: Event<Payload> = (\n    payload: Payload,\n    ...args: any[]\n  ): Payload => instance.create(payload, fullName, args)\n  ;(instance: any).getType = () => fullName\n  //eslint-disable-next-line no-unused-vars\n  ;(instance: any).create = (payload, fullName, args) => {\n    launch(instance, payload)\n    return payload\n  }\n  ;(instance: any).kind = Kind.event\n  ;(instance: any)[$$observable] = () => instance\n  ;(instance: any).id = id\n  ;(instance: any).watch = watchEvent.bind(null, instance)\n  ;(instance: any).map = mapEvent.bind(null, instance)\n  ;(instance: any).filter = filterEvent.bind(null, instance)\n  ;(instance: any).prepend = prepend.bind(null, instance)\n  ;(instance: any).subscribe = subscribe.bind(null, instance)\n  ;(instance: any).thru = thru.bind(instance)\n  instance.graphite = graphite\n  instance.shortName = name\n  instance.domainName = parent\n  instance.compositeName = compositeName\n  instance.defaultConfig = config\n\n  return instance\n}\n\nfunction subscribe(event, observer): Subscription {\n  return event.watch(payload => observer.next(payload))\n}\n\nfunction prepend(event, fn: (_: any) => *) {\n  const contramapped: Event<any> = eventFabric({\n    name: '* → ' + event.shortName,\n    parent: event.domainName,\n  })\n  createLink(contramapped, {\n    child: [event],\n    scope: {handler: fn},\n    node: [\n      step.compute({\n        fn: (newValue, {handler}) => handler(newValue),\n      }),\n    ],\n  })\n  return contramapped\n}\n\ndeclare function mapEvent<A, B>(event: Event<A>, fn: (_: A) => B): Event<B>\ndeclare function mapEvent<A, B>(\n  effect: Effect<A, any, any>,\n  fn: (_: A) => B,\n): Event<B>\nfunction mapEvent<A, B>(event: Event<A> | Effect<A, any, any>, fn: A => B) {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' → *',\n    parent: event.domainName,\n  })\n  createLink(event, {\n    child: [mapped],\n    scope: {handler: fn},\n    node: [\n      step.compute({\n        fn: (payload, {handler}) => handler(payload),\n      }),\n    ],\n  })\n  return mapped\n}\n\nfunction filterEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn: {|fn(_: any): boolean|} | (any => any | void),\n): any {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' →? *',\n    parent: event.domainName,\n  })\n  let node\n  let scope\n  //null values not allowed\n  if (typeof fn === 'object') {\n    scope = {fn: fn.fn}\n    node = [\n      step.filter({\n        fn: (upd, {fn}) => fn(upd),\n      }),\n    ]\n  } else {\n    scope = {fn}\n    node = [\n      step.compute({\n        fn: (payload, {fn}) => fn(payload),\n      }),\n      step.filter({\n        fn: result => result !== undefined,\n      }),\n    ]\n  }\n  createLink(event, {\n    scope,\n    child: [mapped],\n    node,\n  })\n  return mapped\n}\n\nfunction watchEvent<Payload>(\n  event: Unit,\n  watcher: (payload: Payload, type: string) => any,\n): Subscription {\n  return createLink(event, {\n    scope: {trigger: event, handler: watcher},\n    //prettier-ignore\n    node: [\n      noop,\n      step.run({\n        fn: (payload: Payload, {trigger, handler}) => handler(\n          payload,\n          getDisplayName(trigger),\n        ),\n      }),\n    ]\n  })\n}\n","//@flow\n\nimport warning from 'warning'\n\nexport type SourceLocation = {|\n  file: string,\n  column: number,\n  line: number,\n|}\n\nexport type EffectConfigPart<Payload, Done> = {\n  handler?: (payload: Payload) => Promise<Done> | Done,\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type StoreConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type EventConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type DomainConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type Config<Part> = {\n  ɔ?: Part,\n  ...Part,\n  ...\n}\n\ndeclare export function normalizeConfig<Payload, Done>(\n  config?: Config<EffectConfigPart<Payload, Done>>,\n): EffectConfigPart<Payload, Done>\ndeclare export function normalizeConfig(\n  config?: Config<StoreConfigPart>,\n): StoreConfigPart\ndeclare export function normalizeConfig(\n  config?: Config<EventConfigPart>,\n): EventConfigPart\ndeclare export function normalizeConfig(\n  config?: Config<DomainConfigPart>,\n): DomainConfigPart\nexport function normalizeConfig(config: any = {}): any {\n  const message =\n    'createStore: Second argument should be plain object, but you passed %s.'\n  warning(typeof config === 'object' && config !== null, message, config)\n  if (typeof config?.ɔ !== 'undefined') {\n    warning(\n      typeof config.ɔ === 'object' && config.ɔ !== null,\n      message,\n      config.ɔ,\n    )\n  }\n  const rawConfig = typeof config.ɔ === 'object' ? config.ɔ : {}\n  const newConfig = Object.assign({}, config, rawConfig)\n  delete newConfig.ɔ\n  return newConfig\n}\n\ndeclare export function normalizeEventConfig<Payload, Done>(\n  nameOrConfig?: string | EffectConfigPart<Payload, Done>,\n  config?: Config<EffectConfigPart<Payload, Done>>,\n): {|\n  config: EffectConfigPart<Payload, Done>,\n  name?: string,\n|}\ndeclare export function normalizeEventConfig(\n  nameOrConfig?: string | EventConfigPart,\n  config?: Config<EventConfigPart>,\n): {|\n  config: EventConfigPart,\n  name?: string,\n|}\ndeclare export function normalizeEventConfig(\n  nameOrConfig?: string | DomainConfigPart,\n  config?: Config<DomainConfigPart>,\n): {|\n  config: DomainConfigPart,\n  name?: string,\n|}\nexport function normalizeEventConfig(\n  nameOrConfig?: string | {...},\n  opts?: any,\n) {\n  const config =\n    typeof nameOrConfig === 'object'\n      ? Object.assign({}, normalizeConfig(opts), nameOrConfig)\n      : normalizeConfig(opts)\n  const name =\n    typeof nameOrConfig === 'object' || typeof nameOrConfig === 'undefined'\n      ? config.name\n      : nameOrConfig\n  return {\n    config,\n    name,\n  }\n}\n","//@flow\n\nimport {eventFabric} from './eventFabric'\nimport {\n  normalizeEventConfig,\n  type EventConfigPart,\n  type Config,\n} from '../config'\nimport type {Event} from './index.h'\n\nexport function createEvent<Payload>(\n  nameOrConfig?: string | EventConfigPart,\n  opts?: Config<EventConfigPart> = {},\n): Event<Payload> {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return eventFabric({\n    name,\n    config,\n  })\n}\n","//@flow\n\nimport {__DEV__} from 'effector/flags'\nimport type {CompositeName} from '../compositeName'\nimport {getDisplayName} from '../naming'\n\ntype StoreMeasurementPhase = 'map' | 'subscribe'\n\nlet currentPhase: StoreMeasurementPhase | null = null\nlet currentPhaseStore: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n} | null = null\n\nconst enableUserTimingAPI = __DEV__\n\nfunction startPhaseTimer(/*::\n  store: {\n    compositeName?: CompositeName,\n    domainName?: CompositeName,\n    +id: string,\n    ...\n  },\n  phase: StoreMeasurementPhase,\n*/) {}\n\nfunction stopPhaseTimer(/*::warning: string | null*/) {}\n\nif (enableUserTimingAPI) {\n  const effectorEmoji = '\\u2604'\n\n  const supportsUserTiming =\n    typeof performance !== 'undefined'\n    && typeof performance.mark === 'function'\n    && typeof performance.clearMarks === 'function'\n    && typeof performance.measure === 'function'\n    && typeof performance.clearMeasures === 'function'\n\n  function formatMarkName(markName: string) {\n    return `${effectorEmoji} ${markName}`\n  }\n\n  const formatLabel = (label: string, warning: string | null) => {\n    const prefix = `${effectorEmoji} `\n    const suffix = warning ? ` Warning: ${warning}` : ''\n    return `${prefix}${label}${suffix}`\n  }\n\n  function getStoreLabel(storeName: string, phase: StoreMeasurementPhase) {\n    return `${storeName}.${phase}`\n  }\n\n  function getStoreMarkName(label: string, debugID: string) {\n    return `${label} (#${debugID})`\n  }\n\n  function beginMark(markName: string) {\n    performance.mark(formatMarkName(markName))\n  }\n\n  function clearMark(markName: string) {\n    performance.clearMarks(formatMarkName(markName))\n  }\n\n  function endMark(label: string, markName: string, warning: string | null) {\n    const formattedMarkName = formatMarkName(markName)\n    const formattedLabel = formatLabel(label, warning)\n    try {\n      performance.measure(formattedLabel, formattedMarkName)\n    } catch (err) {}\n    // Clear marks immediately to avoid growing buffer.\n    performance.clearMarks(formattedMarkName)\n    performance.clearMeasures(formattedLabel)\n  }\n\n  function beginStoreMark(store, phase: StoreMeasurementPhase) {\n    const componentName = getDisplayName(store)\n    const debugID = store.id\n    const label = getStoreLabel(componentName, phase)\n    const markName = getStoreMarkName(label, debugID)\n    beginMark(markName)\n    return true\n  }\n\n  function clearStoreMark(store, phase: StoreMeasurementPhase) {\n    const componentName = getDisplayName(store)\n    const debugID = store.id\n    const label = getStoreLabel(componentName, phase)\n    const markName = getStoreMarkName(label, debugID)\n    clearMark(markName)\n  }\n\n  function endStoreMark(\n    store,\n    phase: StoreMeasurementPhase,\n    warning: string | null,\n  ) {\n    const componentName = getDisplayName(store)\n    const debugID = store.id\n    const label = getStoreLabel(componentName, phase)\n    const markName = getStoreMarkName(label, debugID)\n    endMark(label, markName, warning)\n  }\n\n  const clearPendingPhaseMeasurement = () => {\n    if (currentPhase !== null && currentPhaseStore !== null) {\n      clearStoreMark(currentPhaseStore, currentPhase)\n    }\n    currentPhaseStore = null\n    currentPhase = null\n    //hasScheduledUpdateInCurrentPhase = false\n  }\n\n  startPhaseTimer = function(\n    store: {\n      compositeName?: CompositeName,\n      domainName?: CompositeName,\n      /*::+*/ id: string,\n      /*::...*/\n    },\n    phase: StoreMeasurementPhase,\n  ): void {\n    if (!supportsUserTiming) {\n      return\n    }\n    clearPendingPhaseMeasurement()\n    if (!beginStoreMark(store, phase)) {\n      return\n    }\n    currentPhaseStore = store\n    currentPhase = phase\n  }\n\n  stopPhaseTimer = function(warning: string | null): void {\n    if (!supportsUserTiming) {\n      return\n    }\n    if (currentPhase !== null && currentPhaseStore !== null) {\n      endStoreMark(currentPhaseStore, currentPhase, warning)\n    }\n    currentPhase = null\n    currentPhaseStore = null\n  }\n}\n\nexport {startPhaseTimer, stopPhaseTimer}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport invariant from 'invariant'\nimport {step, readRef, writeRef} from '../stdlib'\nimport {filterChanged, noop} from '../blocks'\nimport {startPhaseTimer, stopPhaseTimer} from '../perf'\nimport {getDisplayName} from '../naming'\nimport {createLink, type Event} from '../event'\nimport type {Store, ThisStore} from './index.h'\nimport type {Subscriber} from '../index.h'\n\nexport function reset(storeInstance: ThisStore, ...events: Array<Event<any>>) {\n  for (const event of events)\n    on.call(this, storeInstance, event, () => storeInstance.defaultState)\n  return this\n}\nexport function getState(storeInstance: ThisStore) {\n  return readRef(storeInstance.plainState)\n}\nexport function off(storeInstance: ThisStore, event: Event<any>) {\n  const currentSubscription = storeInstance.subscribers.get(event)\n  if (currentSubscription === undefined) return\n  currentSubscription()\n  storeInstance.subscribers.delete(event)\n}\n\nexport function on(storeInstance: ThisStore, event: any, handler: Function) {\n  const from: Event<any> = event\n  const oldLink = storeInstance.subscribers.get(from)\n  if (oldLink) oldLink()\n  storeInstance.subscribers.set(\n    from,\n    createLink(from, {\n      scope: {handler, state: storeInstance.plainState, trigger: from},\n      child: [storeInstance],\n      //prettier-ignore\n      node: [\n        step.compute({\n          fn(newValue, {handler, state, trigger}) {\n            const result = handler(\n              readRef(state),\n              newValue,\n              getDisplayName(trigger),\n            )\n            if (result === undefined) return\n            return writeRef(state, result)\n          },\n        }),\n      ]\n    }),\n  )\n  return this\n}\nexport function observable(storeInstance: ThisStore) {\n  const result = {\n    subscribe(observer: Subscriber<any>) {\n      invariant(\n        typeof observer === 'object' && observer !== null,\n        'Expected the observer to be an object.',\n      )\n\n      function observeState(state) {\n        if (observer.next) {\n          observer.next(state)\n        }\n      }\n      return subscribe(storeInstance, observeState)\n    },\n  }\n  //$off\n  result[$$observable] = function() {\n    return this\n  }\n  return result\n}\nexport function watch(\n  storeInstance: ThisStore,\n  eventOrFn: Event<*> | Function,\n  fn?: Function,\n) {\n  const message = 'watch requires function handler'\n  switch (fn && eventOrFn?.kind) {\n    case 'store':\n    case 'event':\n    case 'effect':\n      invariant(typeof fn === 'function', message)\n      return eventOrFn.watch(payload =>\n        //$todo\n        fn(getState(storeInstance), payload, getDisplayName(eventOrFn)),\n      )\n    default:\n      invariant(typeof eventOrFn === 'function', message)\n      return subscribe(storeInstance, eventOrFn)\n  }\n}\nexport function subscribe(storeInstance: ThisStore, listener: Function) {\n  invariant(\n    typeof listener === 'function',\n    'Expected the listener to be a function',\n  )\n  let stopPhaseTimerMessage = 'Got initial error'\n  let lastCall = getState(storeInstance)\n\n  startPhaseTimer(storeInstance, 'subscribe')\n  try {\n    listener(lastCall)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  return createLink(storeInstance, {\n    node: [\n      noop,\n      step.run({\n        fn(args) {\n          let stopPhaseTimerMessage = null\n          startPhaseTimer(storeInstance, 'subscribe')\n          if (args === lastCall) {\n            stopPhaseTimer(stopPhaseTimerMessage)\n            return\n          }\n          lastCall = args\n          try {\n            listener(args)\n          } catch (err) {\n            console.error(err)\n            stopPhaseTimerMessage = 'Got error'\n          }\n          stopPhaseTimer(stopPhaseTimerMessage)\n        },\n      }),\n    ],\n  })\n}\nexport function dispatch(action: any) {\n  return action\n}\n\nexport function mapStore<A, B>(\n  store: Store<A>,\n  fn: (state: A, lastState?: B) => B,\n  firstState?: B,\n): Store<B> {\n  startPhaseTimer(store, 'map')\n  let lastResult\n  let stopPhaseTimerMessage = 'Got initial error'\n  try {\n    const storeState = store.getState()\n    if (storeState !== undefined) {\n      lastResult = fn(storeState, firstState)\n    }\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  const innerStore: Store<any> = this({\n    config: {name: '' + store.shortName + ' → *'},\n    currentState: lastResult,\n    parent: store.domainName,\n  })\n  createLink(store, {\n    child: [innerStore],\n    scope: {store, handler: fn, state: innerStore.stateRef},\n    node: [\n      step.compute({\n        fn(newValue, {state, store, handler}) {\n          startPhaseTimer(store, 'map')\n          let stopPhaseTimerMessage = 'Got error'\n          let result\n          try {\n            result = handler(newValue, readRef(state))\n            stopPhaseTimerMessage = null\n          } catch (err) {\n            console.error(err)\n          }\n          stopPhaseTimer(stopPhaseTimerMessage)\n          return result\n        },\n      }),\n      filterChanged,\n    ],\n  })\n  return innerStore\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport {launch} from '../kernel'\nimport {step, createGraph, Kind, createStateRef} from '../stdlib'\nimport {createEvent, forward} from '../event'\n\nimport type {Store, ThisStore} from './index.h'\nimport type {StoreConfigPart as ConfigPart} from '../config'\nimport {createName, type CompositeName} from '../compositeName'\nimport {thru} from '../thru'\nimport {\n  reset,\n  getState,\n  off,\n  on,\n  observable,\n  watch,\n  subscribe,\n  dispatch,\n  mapStore,\n} from './storeMethods'\n\nexport function storeFabric<State>(props: {\n  currentState: State,\n  config: ConfigPart,\n  parent?: CompositeName,\n  ...\n}): Store<State> {\n  const {currentState, config, parent} = props\n  const {name} = config\n  const plainState = createStateRef(currentState)\n  const currentId = name || plainState.id\n  const defaultState = currentState\n  const compositeName = createName(currentId, parent)\n\n  const updates: any = createEvent('update ' + currentId)\n  const storeInstance: ThisStore = {\n    graphite: createGraph({\n      scope: {state: plainState, oldState: currentState},\n      node: [\n        step.filter({\n          fn: upd => upd !== undefined,\n        }),\n        step.update({\n          store: plainState,\n        }),\n        step.filter({\n          fn(upd, scope) {\n            if (upd === scope.oldState) return false\n            scope.oldState = upd\n            return true\n          },\n        }),\n      ],\n    }),\n    kind: Kind.store,\n    id: plainState.id,\n    shortName: currentId,\n    domainName: parent,\n    defaultConfig: config,\n    defaultState,\n    plainState,\n    subscribers: new Map(),\n    compositeName,\n  }\n  const store: $Shape<Store<State>> = {\n    compositeName: storeInstance.compositeName,\n    graphite: storeInstance.graphite,\n    kind: Kind.store,\n    id: plainState.id,\n    shortName: currentId,\n    domainName: parent,\n    setState,\n    off: off.bind(null, storeInstance),\n    watch: watch.bind(null, storeInstance),\n    updates,\n    subscribe: subscribe.bind(null, storeInstance),\n    getState: getState.bind(null, storeInstance),\n    stateRef: plainState,\n  }\n  ;(store: any).defaultConfig = config\n  ;(store: any).reset = reset.bind(store, storeInstance)\n  ;(store: any).on = on.bind(store, storeInstance)\n  ;(store: any).defaultState = defaultState\n  ;(store: any).map = mapStore.bind(storeFabric, store)\n  ;(store: any).thru = thru.bind(store)\n  ;(store: any).dispatch = dispatch.bind(null)\n  //$off\n  store[$$observable] = observable.bind(null, storeInstance)\n  forward({\n    from: store,\n    to: updates,\n  })\n\n  function setState(value, reduce?: Function) {\n    const state = getState(storeInstance)\n    const newResult =\n      typeof reduce === 'function' ? reduce(state, value) : value\n\n    launch(store, newResult)\n  }\n\n  return store\n}\n","//@flow\n\nimport invariant from 'invariant'\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\nimport {type Config, type StoreConfigPart, normalizeConfig} from '../config'\n\nexport function createStore<State>(\n  state: State,\n  config: Config<StoreConfigPart> = {},\n): Store<State> {\n  invariant(\n    typeof state !== 'undefined',\n    \"createStore: First argument can't be undefined, use null instead.\",\n  )\n  const opts = normalizeConfig(config)\n  return storeFabric({\n    currentState: state,\n    config: opts,\n  })\n}\n","//@flow\nimport {\n  step,\n  nextBarrierID,\n  createStateRef,\n  readRef,\n  writeRef,\n  type StateRef,\n} from '../stdlib'\nimport {is} from '../validate'\nimport {unitObjectName} from '../naming'\nimport {createLink} from '../event'\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\ntype CombinationScope = {\n  key: any,\n  target: StateRef,\n  clone(value: any): any,\n  isFresh: StateRef,\n  ...\n}\n\nconst storeCombination = (obj: any, clone: Function, defaultState: any) => {\n  const node = [\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {target, key}: CombinationScope) => (\n        upd !== readRef(target)[key]\n      && upd !== undefined\n      ),\n    }),\n    step.tap({\n      fn(upd, {isFresh, target, clone}: CombinationScope) {\n        if (readRef(isFresh)) return\n        writeRef(target, clone(readRef(target)))\n        writeRef(isFresh, true)\n      },\n    }),\n    step.tap({\n      fn(upd, {target, key}: CombinationScope) {\n        readRef(target)[key] = upd\n      },\n    }),\n    step.barrier({barrierID: nextBarrierID()}),\n    step.compute({\n      fn(none, {isFresh, target}: CombinationScope) {\n        writeRef(isFresh, false)\n        return readRef(target)\n      },\n    }),\n  ]\n  const stateNew = clone(defaultState)\n  const store = storeFabric({\n    currentState: stateNew,\n    //TODO: add location\n    config: {name: unitObjectName(obj)},\n  })\n  const isFresh = createStateRef(false)\n  for (const key in obj) {\n    const child = obj[key]\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      continue\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    createLink(child, {\n      scope: {key, clone, target: store.stateRef, isFresh},\n      node,\n      child: [store],\n    })\n  }\n\n  ;(store: any).defaultShape = obj\n  ;(store: any).defaultState = defaultState\n  return store\n}\n\ndeclare export function createStoreObject<\n  State: $ReadOnlyArray<Store<any> | any>,\n>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function createStoreObject<\n  State: {-[key: string]: Store<any> | any, ...},\n>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\n//prettier-ignore\nexport function createStoreObject(obj: *, fn?: Function) {\n  const mergedStore = Array.isArray(obj)\n    ? storeCombination(\n      obj,\n      list => list.slice(),\n      [],\n    )\n    : storeCombination(\n      obj,\n      obj => Object.assign({}, obj),\n      {},\n    )\n  return fn\n    ? mergedStore.map(fn)\n    : mergedStore\n}\n//eslint-disable-next-line\ndeclare export function extract<\n  State: $ReadOnlyArray<Store<any> | any>,\n  NextState: $ReadOnlyArray<Store<any> | any>,\n>(\n  store: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $TupleMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function extract<\n  State: {-[key: string]: Store<any> | any, ...},\n  NextState: {-[key: string]: Store<any> | any, ...},\n>(\n  obj: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $ObjMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function extract(store: Store<any>, extractor: any => any) {\n  let result\n  if ('defaultShape' in store) result = extractor((store: any).defaultShape)\n  else result = extractor((store: any).defaultState)\n  return createStoreObject(result)\n}\n","//@flow\nimport type {Event} from '../event'\nimport type {Effect} from '../effect'\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\nimport {is} from '../validate'\n\nexport function restoreObject<State: {+[key: string]: Store<any> | any, ...}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n> {\n  const result = {}\n  for (const key in obj) {\n    const value = obj[key]\n    if (is.store(value)) {\n      result[key] = value\n    } else {\n      result[key] = storeFabric({\n        currentState: value,\n        config: {name: key},\n      })\n    }\n  }\n  return result\n}\n\nexport function restoreEffect<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done> {\n  const store = storeFabric({\n    currentState: defaultState,\n    parent: event.domainName,\n    //TODO: add location\n    config: {name: event.shortName},\n  })\n  store.on(event.done, (_, {result}) => result)\n  return store\n}\n\nexport function restoreEvent<E>(event: Event<E>, defaultState: E): Store<E> {\n  const store = storeFabric({\n    currentState: defaultState,\n    parent: event.domainName,\n    //TODO: add location\n    config: {name: event.shortName},\n  })\n  store.on(event, (_, v) => v)\n  return store\n}\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function restore<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done>\ndeclare export function restore<E>(event: Event<E>, defaultState: E): Store<E>\ndeclare export function restore<State: {-[key: string]: Store<any> | any, ...}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n>\nexport function restore(obj: any, defaultState: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.event(obj)) {\n    return restoreEvent(obj, defaultState)\n  }\n  if (is.effect(obj)) {\n    return restoreEffect(obj, defaultState)\n  }\n  return restoreObject(obj)\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport {type Store, createStoreObject} from './store'\nimport {is} from './validate'\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function combine<R>(fn: () => R): Store<R>\ndeclare export function combine<A, R>(a: Store<A>, fn: (a: A) => R): Store<R>\ndeclare export function combine<A, B, R>(\n  a: Store<A>,\n  b: Store<B>,\n  fn: (a: A, b: B) => R,\n): Store<R>\ndeclare export function combine<A, B, C, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  fn: (a: A, b: B, c: C) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  fn: (a: A, b: B, c: C, d: D) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  fn: (a: A, b: B, c: C, d: D, e: E) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, K, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  k: Store<K>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) => R,\n): Store<R>\n\nexport function combine(...args: Array<Store<any>>): Store<any> {\n  invariant(args.length > 0, 'at least one argument required')\n  let handler\n  let stores\n  {\n    const rawHandler = args[args.length - 1]\n    if (typeof rawHandler === 'function') {\n      stores = args.slice(0, -1)\n      handler = rawHandler\n    } else {\n      stores = args\n    }\n  }\n\n  let structStoreShape\n\n  makeShape: {\n    if (stores.length === 1) {\n      const obj = stores[0]\n      /*\n      without edge case combine(Color, (Color) => '~')\n      */\n      if (!is.store(obj)) {\n        /*\n        case combine([R,G,B], ([R,G,B]) => '~')\n        case combine({R,G,B}, ({R,G,B}) => '~')\n\n        edge case combine([Color], ([Color]) => '~')\n        edge case combine({Color}, ({Color}) => '~')\n\n        edge case combine([R,G,B])\n        edge case combine({R,G,B})\n\n        edge case combine([Color])\n        edge case combine({Color})\n        */\n        structStoreShape = obj\n        break makeShape\n      }\n    }\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  //$off\n  return createStoreObject(structStoreShape, handler)\n}\n\nconst spreadArgs = fn => list => fn(...list)\n","//@flow\n\nimport warning from 'warning'\nimport type {Effect} from './index.h'\nimport {Kind, step} from '../stdlib'\nimport {upsertLaunch} from '../kernel'\nimport {eventFabric, type Event} from '../event'\nimport {createStore} from '../store'\nimport type {EffectConfigPart} from '../config'\nimport type {CompositeName} from '../compositeName'\n\nfunction OnResolve(result) {\n  const {event, params, handler} = this\n  //prettier-ignore\n  upsertLaunch(event, {\n    handler,\n    toHandler: result,\n    result: {\n      params,\n      result,\n    },\n  })\n}\nfunction OnReject(error) {\n  const {event, params, handler} = this\n  //prettier-ignore\n  upsertLaunch(event, {\n    handler,\n    toHandler: error,\n    result: {\n      params,\n      error,\n    },\n  })\n}\n\nfunction Def() {\n  /*::\n  this.rs = result => {}\n  this.rj = error => {}\n  */\n  const req = new Promise((rs, rj) => {\n    this.rs = rs\n    this.rj = rj\n  })\n  //$off\n  req.anyway = () => {\n    warning(false, '.anyway is deprecated, use .finally')\n    return req.then(() => {}, () => {})\n  }\n  this.req = req\n}\n\nconst notifyHandler = step.run({\n  fn({handler, toHandler, result}, scope) {\n    handler(toHandler)\n    return result\n  },\n})\nexport function effectFabric<Payload, Done>({\n  name,\n  domainName,\n  parent,\n  config,\n}: {\n  name?: string,\n  domainName: string,\n  parent?: CompositeName,\n  config: EffectConfigPart<Payload, Done>,\n  ...\n}): Effect<Payload, Done, *> {\n  const {handler} = config\n\n  //$off\n  const instance: Effect<Payload, Done, any> = eventFabric({\n    name,\n    parent,\n    config,\n  })\n\n  const eventCreate = instance.create\n  const done: Event<{|\n    params: Payload,\n    result: Done\n  |}> = eventFabric({\n    name: '' + instance.shortName + ' done',\n    parent,\n    config,\n  })\n  const fail: Event<{|\n    params: Payload,\n    error: *\n  |}> = eventFabric({\n    name: '' + instance.shortName + ' fail',\n    parent,\n    config,\n  })\n  done.graphite.seq.push(notifyHandler)\n  fail.graphite.seq.push(notifyHandler)\n  //eslint-disable-next-line no-unused-vars\n  let thunk: Function = handler || defaultThunk.bind(instance)\n\n  instance.done = done\n  instance.fail = fail\n  ;(instance: any).use = fn => {\n    thunk = fn\n    return instance\n  }\n  const getCurrent = (): any => thunk\n  ;(instance: any).use.getCurrent = getCurrent\n  ;(instance: any).kind = Kind.effect\n  //assume that fresh event has empty scope\n  ;(instance: any).graphite.scope = {done, fail, getHandler: getCurrent}\n  instance.graphite.seq.push(\n    step.compute({\n      fn(params, scope) {\n        if (typeof params === 'object' && params !== null) {\n          if ('ɔ' in params) return params.ɔ\n        }\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn({params, req}, {getHandler, done, fail}) {\n        runEffect(\n          getHandler(),\n          params,\n          OnResolve.bind({event: done, params, handler: req.rs}),\n          OnReject.bind({event: fail, params, handler: req.rj}),\n        )\n        return params\n      },\n    }),\n  )\n  ;(instance: any).create = (params: Payload, fullName, args) => {\n    const req = new Def()\n    eventCreate({ɔ: {params, req}}, instance.getType(), args)\n    return req.req\n  }\n  /* terser will minify true and false to 1 and 0,\n    thereby we need to define true as Boolean(1)\n    and false as Boolean(0) */\n  instance.pending = createStore(Boolean(0))\n    .on(instance, () => Boolean(1))\n    .reset(done)\n    .reset(fail)\n  return instance\n}\nfunction runEffect(handler, params, onResolve, onReject) {\n  let failedSync = false\n  let syncError\n  let rawResult\n  try {\n    rawResult = handler(params)\n  } catch (err) {\n    failedSync = true\n    syncError = err\n  }\n  if (failedSync) {\n    onReject(syncError)\n    return\n  }\n  if (typeof rawResult === 'object' && rawResult !== null) {\n    if (typeof rawResult.then === 'function') {\n      rawResult.then(onResolve, onReject)\n      return\n    }\n  }\n  onResolve(rawResult)\n}\n//eslint-disable-next-line no-unused-vars\nfunction defaultThunk(value) {\n  warning(false, 'no thunk used in %s', this.getType())\n  return Promise.resolve()\n}\n","//@flow\n\nexport const __DEBUG__ = false\nexport const __DEV__ = process.env.NODE_ENV !== 'production'\nexport const __CANARY__ = false\n\nexport {version} from '../../packages/effector/package.json'\n","//@flow\n/* eslint-disable */\nimport {__DEV__} from 'effector/flags'\n\nexport default (__DEV__\n  ? function invariant(condition: any, format: string, ...args: any) {\n      if (!condition) {\n        const error = Error()\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(error, invariant)\n        }\n        error.name = 'Invariant Violation'\n        let argIndex = 0\n        error.message = format.replace(/%s/g, () => args[argIndex++])\n        throw error\n      }\n    }\n  : function invariant(condition: any /*::, format: string, ...args: any*/) {\n      if (!condition) {\n        throw Error('Minified exception occurred')\n      }\n    })\n","//@flow\n\nimport type {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const stringRefcount = (): (() => string) => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n","//@flow\nimport type {\n  StateRef,\n  NodeMeta,\n  Update,\n  Run,\n  Tap,\n  Filter,\n  Emit,\n  Compute,\n  Barrier,\n  ID,\n} from './index.h'\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\n\nconst cmd = (type: any, data: any): any => ({\n  id: nextID(),\n  type,\n  group: 'cmd',\n  data,\n})\n\nexport const step: {|\n  barrier(data: {|\n    +barrierID: ID,\n    +priority?: 'barrier' | 'sampler',\n    meta?: NodeMeta,\n  |}): Barrier,\n  emit(data: {|\n    fullName: string,\n    meta?: NodeMeta,\n  |}): Emit,\n  compute(data: {|\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  |}): Compute,\n  filter(data: {|\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  |}): Filter,\n  run(data: {\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  }): Run,\n  tap(data: {\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  }): Tap,\n  update(data: {|\n    store: StateRef,\n    meta?: NodeMeta,\n  |}): Update,\n|} = {\n  barrier: ({barrierID, priority = 'barrier'}) =>\n    cmd('barrier', {\n      barrierID,\n      priority,\n    }),\n  compute: cmd.bind(null, 'compute'),\n  emit: cmd.bind(null, 'emit'),\n  filter: cmd.bind(null, 'filter'),\n  run: cmd.bind(null, 'run'),\n  tap: cmd.bind(null, 'tap'),\n  update: cmd.bind(null, 'update'),\n}\n","//@flow\nimport type {StateRef} from './index.h'\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextID(),\n  current,\n})\n\nexport const readRef = ({current}: StateRef | {current: any, ...}) => current\nexport const writeRef = (ref: StateRef | {current: any, ...}, value: any) =>\n  (ref.current = value)\n","//@flow\n\nimport {stringRefcount} from './refcount'\nexport const nextBarrierID = stringRefcount()\n","// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n//@flow\n/* eslint-disable */\n\nexport type PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\nexport const getPriority = (t: PriorityTag) => {\n  switch(t) {\n    case 'child': return 0\n    case 'pure': return 1\n    case 'barrier': return 2\n    case 'sampler': return 3\n    case 'effect': return 4\n    default: return -1\n  }\n}","//@flow\n\nimport type {\n  Graph,\n  Graphite,\n  StateRef,\n  Cmd,\n  Emit,\n  Run,\n  Update,\n  Filter,\n  Compute,\n  Barrier,\n  Tap,\n} from '../stdlib'\nimport {getGraph, writeRef, readRef} from '../stdlib'\n\nimport {getPriority, type PriorityTag} from './getPriority'\n\nclass Stack {\n  /*::\n  value: {current: any}\n  parent: Stack | null\n  */\n  constructor(value: any, parent: Stack | null) {\n    this.value = {current: value}\n    this.parent = parent\n  }\n}\n\ntype Layer = {|\n  +step: Graph,\n  +firstIndex: number,\n  +scope: Stack,\n  +resetStop: boolean,\n  +type: PriorityTag,\n  +id: number,\n|}\n\nexport class Leftist {\n  /*::\n  left: leftist\n  right: leftist\n  value: Layer\n  rank: number\n  */\n  constructor(value: Layer, rank: number, left: leftist, right: leftist) {\n    this.value = value\n    this.rank = rank\n    this.left = left\n    this.right = right\n  }\n}\nexport type leftist = null | Leftist\nconst insert = (x: Layer, t: leftist): leftist =>\n  merge(new Leftist(x, 1, null, null), t)\n\nconst deleteMin = (param: leftist): leftist => {\n  if (param) {\n    return merge(param.left, param.right)\n  }\n  return null\n}\nconst merge = (_t1: leftist, _t2: leftist): leftist => {\n  let t2\n  let t1\n  let k1\n  let l\n  let merged\n  let rank_left\n  let rank_right\n  while (true) {\n    t2 = _t2\n    t1 = _t1\n    if (!t1) return t2\n    if (!t2) return t1\n    k1 = t1.value\n    l = t1.left\n    if (layerComparator(k1, t2.value)) {\n      _t2 = t1\n      _t1 = t2\n      continue\n    }\n    merged = merge(t1.right, t2)\n    rank_left = l?.rank || 0\n    rank_right = merged?.rank || 0\n    if (rank_left >= rank_right) {\n      return new Leftist(k1, rank_right + 1, l, merged)\n    }\n    return new Leftist(k1, rank_left + 1, merged, l)\n  }\n  /*::return _t1*/\n}\nclass Local {\n  /*::\n  isChanged: boolean\n  isFailed: boolean\n  scope: {[key: string]: any, ...}\n  */\n  constructor(scope: {[key: string]: any, ...}) {\n    this.isChanged = true\n    this.isFailed = false\n    this.scope = scope\n  }\n}\nconst layerComparator = (a: Layer, b: Layer) => {\n  if (a.type === b.type) return a.id > b.id\n  return getPriority(a.type) > getPriority(b.type)\n}\nlet layerID = 0\nlet heap: leftist = null\nconst barriers = new Set()\nconst pushHeap = (opts: Layer) => {\n  heap = insert(opts, heap)\n}\nconst runGraph = ({step: graph, firstIndex, scope, resetStop}: Layer, meta) => {\n  const local = new Local(graph.scope)\n  for (\n    let stepn = firstIndex;\n    stepn < graph.seq.length && !meta.stop;\n    stepn++\n  ) {\n    const step = graph.seq[stepn]\n    if (stepn === firstIndex) {\n      if (step.type === 'barrier') {\n        barriers.delete(step.data.barrierID)\n      }\n    } else {\n      switch (step.type) {\n        case 'run':\n          pushHeap({\n            step: graph,\n            firstIndex: stepn,\n            scope,\n            resetStop: false,\n            type: 'effect',\n            id: ++layerID,\n          })\n          return\n        case 'barrier': {\n          const id = step.data.barrierID\n          if (!barriers.has(id)) {\n            barriers.add(id)\n            pushHeap({\n              step: graph,\n              firstIndex: stepn,\n              scope,\n              resetStop: false,\n              type: step.data.priority,\n              id: ++layerID,\n            })\n          }\n          return\n        }\n      }\n    }\n    const cmd = command[step.type]\n    //$todo\n    cmd(local, step.data, scope.value)\n    meta.stop = local.isFailed || !local.isChanged\n  }\n  if (!meta.stop) {\n    for (let stepn = 0; stepn < graph.next.length; stepn++) {\n      /**\n       * copy head of scope stack to feel free\n       * to override it during seq execution\n       */\n      const subscope = new Stack(readRef(scope.value), scope)\n      pushHeap({\n        step: graph.next[stepn],\n        firstIndex: 0,\n        scope: subscope,\n        resetStop: true,\n        type: 'child',\n        id: ++layerID,\n      })\n    }\n  }\n  if (resetStop) {\n    meta.stop = false\n  }\n}\n\nlet alreadyStarted = false\n\nconst addSingleBranch = (unit: Graphite, payload: any) => {\n  pushHeap({\n    step: getGraph(unit),\n    firstIndex: 0,\n    scope: new Stack(payload, null),\n    resetStop: false,\n    type: 'pure',\n    id: ++layerID,\n  })\n}\n\nconst exec = () => {\n  const lastStartedState = alreadyStarted\n  alreadyStarted = true\n  const meta = {\n    stop: false,\n  }\n  let value\n  while (heap) {\n    value = heap.value\n    heap = deleteMin(heap)\n    runGraph(value, meta)\n  }\n  alreadyStarted = lastStartedState\n}\nexport const launch = (unit: Graphite, payload: any) => {\n  addSingleBranch(unit, payload)\n  exec()\n}\nexport const upsertLaunch = (unit: Graphite, payload: any) => {\n  addSingleBranch(unit, payload)\n  if (alreadyStarted) return\n  exec()\n}\nconst command = {\n  barrier(local, step: $PropertyType<Barrier, 'data'>, val: StateRef) {\n    local.isFailed = false\n    local.isChanged = true\n  },\n  emit(local, step: $PropertyType<Emit, 'data'>, val: StateRef) {},\n  filter(local, step: $PropertyType<Filter, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    /**\n     * .isFailed assignment is not needed because in such case\n     * runCtx.result will be null\n     * thereby successfully forcing that branch to stop\n     */\n    local.isChanged = !!runCtx.result\n  },\n  run(local, step: $PropertyType<Run, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n    writeRef(val, runCtx.result)\n  },\n  update(local, step: $PropertyType<Update, 'data'>, val: StateRef) {\n    writeRef(step.store, readRef(val))\n  },\n  compute(local, step: $PropertyType<Compute, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n    writeRef(val, runCtx.result)\n  },\n  tap(local, step: $PropertyType<Tap, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n  },\n}\nconst tryRun = ({fn, arg, val}: any) => {\n  const result = {\n    err: false,\n    result: null,\n  }\n  try {\n    result.result = fn(arg, val)\n  } catch (err) {\n    console.error(err)\n    result.err = true\n  }\n  return result\n}\n","//@flow\n\nimport {step, readRef} from './stdlib'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== readRef(state)\n    && data !== undefined\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n","//@flow\nimport {__DEV__} from 'effector/flags'\n\nexport default (__DEV__\n  ? (condition: any, format: string, ...args: any) => {\n    if (!condition) {\n      console.error('Warning: ' + format, ...args)\n    }\n  }\n  : (/*::condition: any, format: string, ...args: any*/) => {})\n","//@flow\n\nimport {Kind, type kind} from '../stdlib'\n\nexport const unit = (obj: mixed) =>\n  (typeof obj === 'function' || (typeof obj === 'object' && obj !== null))\n  //$off\n  && 'kind' in obj\n\n//$off\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(Kind.store)\nexport const event = is(Kind.event)\nexport const effect = is(Kind.effect)\nexport const domain = is(Kind.domain)\n","//@flow\nimport {type Graphite, type Cmd, getGraph, createGraph} from '../stdlib'\nimport type {Subscription} from '../index.h'\nimport {createWatcher} from '../watcher'\n\nexport const createLink = (\n  from: Graphite,\n  opts: {|\n    +node: Array<Cmd>,\n    +child?: Array<Graphite>,\n    scope?: {[name: string]: any, ...},\n    meta?: {[name: string]: any, ...},\n  |},\n) =>\n  forward({\n    from,\n    to: createGraph(opts),\n  })\n\nexport const forward = (opts: {|\n  from: Graphite,\n  to: Graphite\n|}): Subscription => {\n  const from = getGraph(opts.from)\n  const to = getGraph(opts.to)\n  from.next.push(to)\n  //TODO push parent to .from field\n  // to.from.push(from)\n  return createWatcher({\n    child: to,\n    parent: from,\n  })\n}\n","//@flow\n/* eslint-disable no-nested-ternary */\nimport {is} from './validate'\nimport {eventFabric, createLink, forward} from './event'\nimport {storeFabric, createStoreObject} from './store'\nimport {noop} from './blocks'\nimport {\n  step,\n  type Graphite,\n  createStateRef,\n  readRef,\n  writeRef,\n  nextBarrierID,\n} from './stdlib'\n\nconst storeBy = (source, clock, fn, greedy, target) => {\n  createLink(clock, {\n    scope: {\n      state: source.stateRef,\n      fn,\n    },\n    child: [target],\n    node: [\n      //$off\n      !greedy && noop,\n      //$off\n      !greedy\n        && step.barrier({\n          barrierID: nextBarrierID(),\n          priority: 'sampler',\n        }),\n      step.compute({\n        fn: fn\n          ? (upd, {state, fn}) => fn(readRef(state), upd)\n          : (upd, {state}) => readRef(state),\n      }),\n    ].filter(Boolean),\n  })\n  return target\n}\n\nconst storeByEvent = (source: any, clock: any, fn: any, greedy, target) =>\n  storeBy(\n    source,\n    clock,\n    fn,\n    greedy,\n    target\n      || eventFabric({\n        name: source.shortName,\n        parent: source.domainName,\n      }),\n  )\n\nconst storeByStore = (source: any, clock: any, fn: any, greedy, target) => {\n  const sourceState = readRef(source.stateRef)\n  return storeBy(\n    source,\n    clock,\n    fn,\n    greedy,\n    target\n      || storeFabric({\n        currentState: fn\n          ? fn(sourceState, readRef(clock.stateRef))\n          : sourceState,\n        config: {name: source.shortName},\n        parent: source.domainName,\n      }),\n  )\n}\n\nconst eventByUnit = (source: any, clock: any, fn: any, greedy, target) => {\n  target =\n    target\n    || eventFabric({\n      name: source.shortName,\n      parent: source.domainName,\n    })\n  const hasSource = createStateRef(false)\n  const sourceState = createStateRef()\n  const clockState = createStateRef()\n\n  createLink(source, {\n    scope: {hasSource},\n    node: [\n      step.update({store: sourceState}),\n      step.tap({\n        fn(upd, {hasSource}) {\n          writeRef(hasSource, true)\n        },\n      }),\n    ],\n  })\n\n  createLink(clock, {\n    scope: {sourceState, clockState, hasSource, fn},\n    child: [target],\n    node: [\n      step.update({store: clockState}),\n      step.filter({\n        fn: (upd, {hasSource}) => readRef(hasSource),\n      }),\n      //$off\n      !greedy\n        && step.barrier({\n          barrierID: nextBarrierID(),\n          priority: 'sampler',\n        }),\n      step.compute({\n        fn: fn\n          ? (upd, {sourceState, clockState, fn}) =>\n            fn(readRef(sourceState), readRef(clockState))\n          : (upd, {sourceState}) => readRef(sourceState),\n      }),\n    ].filter(Boolean),\n  })\n  return target\n}\n\nexport function sample(\n  source: any,\n  clock: Graphite,\n  fn?: boolean | ((source: any, clock: any) => any),\n  greedy: boolean = false,\n): any {\n  let target\n  //config case\n  if (clock === undefined && 'source' in source) {\n    clock = source.clock || source.sampler\n    fn = source.fn\n    greedy = source.greedy\n    //optional target accepted only from config\n    target = source.target\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  const sourceNorm = unitOrCombine(source)\n  const clockNorm = unitOrCombine(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = undefined\n  }\n  //prettier-ignore\n  const combinator =\n    is.store(sourceNorm)\n      ? is.store(clockNorm)\n        ? storeByStore\n        : storeByEvent\n      : eventByUnit\n  return combinator(sourceNorm, clockNorm, fn, greedy, target)\n}\n\n//prettier-ignore\nconst unitOrCombine = (obj: any) => is.unit(obj)\n  ? obj\n  : createStoreObject(obj)\n","//@flow\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {Store} from '../store'\nimport {type Event, eventFabric} from '../event'\nimport type {Effect} from '../effect'\nimport type {CompositeName} from '../compositeName'\nexport class DomainHistory {\n  /*::;+*/ events: Set<Event<any>> = new Set()\n  /*::;+*/ effects: Set<Effect<any, any, any>> = new Set()\n  /*::;+*/ storages: Set<Store<any>> = new Set()\n  /*::;+*/ domains: Set<Domain> = new Set()\n}\n\nexport function domainHooks(\n  history: DomainHistory,\n  compositeName: CompositeName,\n  parentHooks?: DomainHooks,\n) {\n  let hooks: {|\n    domain: Event<Domain>,\n    effect: Event<Effect<any, any, any>>,\n    event: Event<Event<any>>,\n    store: Event<any>,\n  |}\n  if (parentHooks) {\n    hooks = childDomainHooks(parentHooks)\n  } else {\n    hooks = singleDomainHooks(compositeName)\n  }\n  hooks.domain.watch(domain => {\n    history.domains.add(domain)\n  })\n  hooks.event.watch(event => {\n    history.events.add(event)\n  })\n  hooks.store.watch(store => {\n    history.storages.add(store)\n  })\n  hooks.effect.watch(effect => {\n    history.effects.add(effect)\n  })\n  return hooks\n}\n\nconst singleDomainHooks = (compositeName: CompositeName) => {\n  const event: Event<Event<any>> = eventFabric({\n    name: `${compositeName.fullName} event hook`,\n    parent: compositeName,\n  })\n  const effect: Event<Effect<any, any, any>> = eventFabric({\n    name: `${compositeName.fullName} effect hook`,\n    parent: compositeName,\n  })\n  const store: Event<Store<any>> = eventFabric({\n    name: `${compositeName.fullName} store hook`,\n    parent: compositeName,\n  })\n  const domain: Event<Domain> = eventFabric({\n    parent: compositeName,\n  })\n  return {event, effect, store, domain}\n}\n\nconst childDomainHooks = (parentHooks: DomainHooks) => {\n  const event: Event<Event<any>> = parentHooks.event.prepend(_ => _)\n  const effect: Event<Effect<any, any, any>> = parentHooks.effect.prepend(\n    _ => _,\n  )\n  const store: Event<Store<any>> = parentHooks.store.prepend(_ => _)\n  const domain: Event<Domain> = parentHooks.domain.prepend(_ => _)\n  return {event, effect, store, domain}\n}\n","//@flow\n\nimport {stringRefcount, Kind} from '../stdlib'\nimport {type Store, storeFabric} from '../store'\nimport {\n  normalizeConfig,\n  type Config,\n  type EffectConfigPart,\n  type EventConfigPart,\n  type StoreConfigPart,\n} from '../config'\nimport {type Event, eventFabric} from '../event'\nimport {type Effect, effectFabric} from '../effect'\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {DomainConfigPart} from '../config'\nimport {createName, type CompositeName} from '../compositeName'\nimport {DomainHistory, domainHooks} from './hook'\n\nconst nextID = stringRefcount()\n\nexport function domainFabric({\n  name: nameRaw,\n  config = {},\n  parent,\n  parentHooks,\n}: {\n  name?: string,\n  config?: DomainConfigPart,\n  parent?: CompositeName,\n  parentHooks?: DomainHooks,\n  ...\n}): Domain {\n  const id = nextID()\n  const name = nameRaw || ''\n  const compositeName = createName(name, parent)\n  const history = new DomainHistory()\n  const hooks = domainHooks(history, compositeName, parentHooks)\n\n  return {\n    compositeName,\n    id,\n    defaultConfig: config,\n    getType() {\n      return compositeName.fullName\n    },\n    onCreateEvent(hook: (newEvent: Event<any>) => any) {\n      history.events.forEach(hook)\n      return hooks.event.watch(hook)\n    },\n    onCreateEffect(hook: (newEffect: Effect<any, any, any>) => any) {\n      history.effects.forEach(hook)\n      return hooks.effect.watch(hook)\n    },\n    onCreateStore(hook: (newStore: Store<any>) => any) {\n      history.storages.forEach(hook)\n      return hooks.store.watch(hook)\n    },\n    onCreateDomain(hook: (newDomain: Domain) => any) {\n      history.domains.forEach(hook)\n      return hooks.domain.watch(hook)\n    },\n    event<Payload>(\n      name?: string,\n      config: Config<EventConfigPart> = {},\n    ): Event<Payload> {\n      const opts = normalizeConfig(config)\n      const result = eventFabric({\n        name,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.event(result)\n      return result\n    },\n    effect<Params, Done, Fail>(\n      name?: string,\n      config: Config<EffectConfigPart<Params, Done>> = {},\n    ): Effect<Params, Done, Fail> {\n      const opts = normalizeConfig(config)\n      const result = effectFabric({\n        name,\n        domainName: compositeName.fullName,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.effect(result)\n      return result\n    },\n    domain(name?: string, config: Config<DomainConfigPart> = {}) {\n      const opts = normalizeConfig(config)\n      const result = domainFabric({\n        name,\n        parent: compositeName,\n        parentHooks: hooks,\n        config: opts,\n      })\n      hooks.domain(result)\n      return result\n    },\n    store<T>(state: T, config: Config<StoreConfigPart> = {}): Store<T> {\n      const opts = normalizeConfig(config)\n      const result = storeFabric({\n        currentState: state,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.store(result)\n      return result\n    },\n    kind: Kind.domain,\n  }\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {type Event, createEvent} from '../event'\n\ndeclare export function createApi<\n  S,\n  Obj: {-[name: string]: (store: S, e: any) => S, ...},\n>(\n  store: Store<S>,\n  setters: Obj,\n): $ObjMap<Obj, <E>(h: (store: S, e: E) => S) => Event<E>>\n\nexport function createApi(store: Store<any>, setters: {[string]: Function, ...}) {\n  const result = {}\n  for (const key in setters) {\n    const handler: any = setters[key]\n    const event = (result[key] = createEvent(key))\n    store.on(event, handler)\n  }\n  return result\n}\n","//@flow\n\nimport {domainFabric} from './domainFabric'\nimport {normalizeEventConfig, type Config, type DomainConfigPart} from '../config'\n\nexport function createDomain(\n  nameOrConfig?: string | DomainConfigPart,\n  opts?: Config<DomainConfigPart> = {},\n) {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return domainFabric({\n    name: name === undefined ? '' : name,\n    config,\n  })\n}\n","//@flow\n\nimport {effectFabric} from './effectFabric'\nimport {\n  normalizeEventConfig,\n  type EffectConfigPart,\n  type Config,\n} from '../config'\nimport type {Effect} from './index.h'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig?: string | EffectConfigPart<Payload, Done>,\n  opts?: Config<EffectConfigPart<Payload, Done>>,\n): Effect<Payload, Done, *> {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return effectFabric({\n    name,\n    domainName: '',\n    config,\n  })\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport $$observable from 'symbol-observable'\nimport {clearNode} from '../stdlib'\nimport {createEvent} from './createEvent'\nimport type {Event} from './index.h'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  invariant(\n    typeof observable === 'function'\n      || (typeof observable === 'object' && observable !== null),\n    'expect observable to be object or function',\n  )\n  const observableItem: any =\n    //$off\n    ($$observable: '@@observable') in observable\n      ? //$off\n      observable[(($$observable: any): '@@observable')]()\n      : observable\n  invariant(\n    'subscribe' in observableItem,\n    'expect observable to have .subscribe',\n  )\n  const event: Event<T> = createEvent()\n  const disposer = clearNode.bind(null, event, {})\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\n\nimport {is} from '../validate'\nimport {__DEBUG__} from 'effector/flags'\nimport type {Store} from './index.h'\nimport {createName} from '../compositeName'\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, store.domainName)\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  //$todo\n  store.compositeName.path = compositeName.path\n  //$todo\n  store.compositeName.shortName = compositeName.shortName\n  //$todo\n  store.compositeName.fullName = compositeName.fullName\n}\n\nexport function storeNaming<Obj: {[key: string]: Store<any> | Object, ...}>(\n  object: Obj,\n  parent?: Store<any>,\n) {\n  for (const storeName in object) {\n    const store: Store<any> = object[storeName]\n    if (!is.store(store)) {\n      console.warn(\n        'effector: Key \"%s\" must be store but instead received %s',\n        storeName,\n        store.kind || '\"' + typeof store + '\"',\n        store,\n      )\n      continue\n    }\n    if (parent) {\n      store.domainName = parent.compositeName || store.domainName\n    }\n    setStoreName(store, storeName)\n    if (store.defaultShape !== undefined) {\n      storeNaming(store.defaultShape, store)\n    }\n  }\n}\n","//@flow\n\nimport type {Store} from './index.h'\n\nexport function withProps<R, S, P>(\n  store: Store<S>,\n  handler: (store: S, props: P) => R,\n): (props: P) => R {\n  return (props: P) => handler(store.getState(), props)\n}\n"],"names":["createGraph","node","child","from","scope","meta","map","getGraph","seq","next","getDisplayName","unit","compositeName","fullName","domainName","id","unitObjectName","objOrArr","i","arr","Object","values","max","unitObjectMaxNames","maxLength","length","name","comma","is","toString","Name","shortName","path","createName","parent","undefined","concat","thru","fn","this","disposer","indexOf","splice","noopIndexOf","noopSplice","eventFabric","nameRaw","config","nextID","graphite","step","emit","instance","payload","args","create","getType","launch","kind","Kind","$$observable","watch","event","watcher","createLink","trigger","handler","noop","run","bind","mapped","compute","filter","upd","result","prepend","contramapped","newValue","subscribe","observer","defaultConfig","normalizeConfig","message","warning","ɔ","newConfig","assign","normalizeEventConfig","nameOrConfig","opts","createEvent","startPhaseTimer","stopPhaseTimer","getState","storeInstance","readRef","plainState","off","currentSubscription","subscribers","get","delete","on","oldLink","set","state","writeRef","eventOrFn","invariant","listener","stopPhaseTimerMessage","lastCall","err","console","error","storeFabric","props","currentState","createStateRef","currentId","defaultState","updates","oldState","update","store","Map","setState","value","reduce","newResult","stateRef","reset","events","call","firstState","lastResult","storeState","innerStore","filterChanged","dispatch","action","forward","to","createStore","createStoreObject","obj","mergedStore","Array","isArray","storeCombination","list","slice","restoreObject","key","restoreEffect","done","_","restoreEvent","v","combine","stores","structStoreShape","rawHandler","makeShape","spreadArgs","Def","req","Promise","rs","rj","anyway","then","effectFabric","eventCreate","fail","push","notifyHandler","thunk","resolve","use","getCurrent","getHandler","params","data","onResolve","onReject","syncError","rawResult","failedSync","runEffect","upsertLaunch","toHandler","pending","Boolean","__DEV__","process","env","NODE_ENV","condition","format","Error","captureStackTrace","argIndex","replace","effect","stringRefcount","cmd","type","group","barrier","barrierID","priority","tap","clearNode","deep","graph","forEach","index","current","ref","nextBarrierID","getPriority","t","Stack","constructor","Leftist","rank","left","right","deleteMin","param","merge","_t1","_t2","t2","t1","k1","l","merged","rank_left","rank_right","layerComparator","Local","isChanged","isFailed","a","b","layerID","heap","barriers","Set","pushHeap","x","insert","runGraph","firstIndex","resetStop","local","stepn","stop","has","add","command","subscope","alreadyStarted","addSingleBranch","exec","lastStartedState","val","runCtx","tryRun","arg","n","domain","unsubscribe","createWatcher","currentPhase","currentPhaseStore","effectorEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","formatMarkName","markName","formatLabel","label","getStoreLabel","storeName","phase","getStoreMarkName","debugID","clearPendingPhaseMeasurement","componentName","clearStoreMark","beginStoreMark","formattedMarkName","formattedLabel","endMark","endStoreMark","clone","target","isFresh","none","stateNew","defaultShape","storeBy","source","clock","greedy","unitOrCombine","DomainHistory","effects","storages","domains","setters","domainFabric","parentHooks","history","hooks","childDomainHooks","singleDomainHooks","domainHooks","onCreateEvent","hook","onCreateEffect","onCreateStore","onCreateDomain","extractor","observable","observableItem","complete","sampler","sourceNorm","clockNorm","sourceState","hasSource","clockState","rawName"],"mappings":"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"}