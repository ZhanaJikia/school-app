{"version":3,"file":"effector.umd.js","sources":["../../src/effector/stdlib/graph.js","../../src/effector/naming.js","../../src/effector/compositeName.js","../../src/effector/thru.js","../../src/effector/watcher/watcher.js","../../src/effector/event/eventFabric.js","../../src/effector/config.js","../../src/effector/event/createEvent.js","../../src/effector/store/storeMethods.js","../../src/effector/store/storeFabric.js","../../src/effector/store/createStore.js","../../src/effector/store/createStoreObject.js","../../src/effector/store/restore.js","../../src/effector/combine.js","../../src/effector/effect/effectFabric.js","../../src/effector/validate/invariant.js","../../node_modules/symbol-observable/es/index.js","../../node_modules/symbol-observable/es/ponyfill.js","../../src/effector/stdlib/kind.js","../../src/effector/stdlib/refcount.js","../../src/effector/stdlib/typedef.js","../../src/effector/stdlib/stateref.js","../../src/effector/stdlib/commonRefcount.js","../../src/effector/kernel/getPriority.js","../../src/effector/kernel/kernel.js","../../src/effector/blocks.js","../../src/effector/validate/warning.js","../../src/effector/validate/is.js","../../src/effector/event/forward.js","../../src/effector/sample.js","../../src/effector/domain/hook.js","../../src/effector/domain/domainFabric.js","../../src/effector/store/createApi.js","../../src/effector/domain/createDomain.js","../../src/effector/effect/createEffect.js","../../src/effector/event/fromObservable.js","../../src/effector/store/setStoreName.js","../../src/effector/store/staticMethods.js"],"sourcesContent":["//@flow\n\nimport type {Graph, Graphite, Cmd} from './index.h'\n\nexport function createGraph({\n  node,\n  child = [],\n  from = [],\n  scope = {},\n  meta = {},\n}: {\n  +node: Array<Cmd>,\n  +child?: Array<Graphite>,\n  +from?: Array<Graphite>,\n  scope?: {[name: string]: any, ...},\n  meta?: {[name: string]: any, ...},\n  ...\n}): Graph {\n  return {\n    from: from.map(getGraph),\n    seq: node,\n    next: child.map(getGraph),\n    meta,\n    scope,\n  }\n}\nexport const clearNode = (\n  graphite: Graphite,\n  {deep}: {\n    deep?: boolean,\n    ...\n  } = {},\n) => {\n  const graph = getGraph(graphite)\n  if (deep) {\n    graph.next.forEach(node => clearNode(node, {deep}))\n  }\n  graph.from.forEach(node => {\n    const index = node.next.indexOf(graph)\n    if (index === -1) return\n    node.next.splice(index, 1)\n  })\n  graph.from.length = 0\n  graph.next.length = 0\n  graph.seq.length = 0\n  //$off\n  graph.scope = null\n}\n\nexport const getGraph = (graph: Graphite): Graph =>\n  (graph: any).graphite || graph\n\nexport const traverse = (\n  graphite: Graphite,\n  {ctx, pre, post}: {ctx: any, pre: Function, post: Function, ...},\n) => {\n  const visited = new Set()\n  const stack = []\n  const walk = (step, layer) => {\n    if (visited.has(step)) return\n    stack.push(step)\n    visited.add(step)\n    pre(step, ctx, stack, layer)\n    const steps = step.next\n    for (let i = 0; i < steps.length; i++) {\n      walk(steps[i], steps)\n    }\n    stack.pop()\n    post(step, ctx, stack, layer)\n  }\n  const graph = getGraph(graphite)\n  walk(graph, [graph])\n  visited.clear()\n  return ctx\n}\n","//@flow\n\nimport type {CompositeName} from './compositeName'\nimport {is} from './validate'\nimport type {Store} from './store'\nimport type {Event} from './event'\nimport type {Effect} from './effect'\n\nexport function getDisplayName(unit: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (unit.compositeName) {\n    return unit.compositeName.fullName\n  }\n  if (unit.domainName) {\n    return unit.domainName.fullName\n  }\n  return unit.id\n}\n\nconst unitObjectMaxNames = 25\n\nexport function unitObjectName(\n  objOrArr:\n    | $ReadOnlyArray<Store<any> | Event<any> | Effect<any, any, any> | any>\n    | {\n        [key: string]: Store<any> | Event<any> | Effect<any, any, any> | any,\n        ...\n      },\n) {\n  let i = 0\n  const arr: Array<any> = Object.values(objOrArr)\n  const max = unitObjectMaxNames - 1\n  const maxLength = arr.length - 1\n  let name = 'combine('\n  for (const unit of arr) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    if (is.store(unit) || is.event(unit) || is.effect(unit)) {\n      name += getDisplayName(unit) + comma\n    } else {\n      name += unit.toString() + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n","//@flow\n\nexport type CompositeName = {|\n  +shortName: string,\n  +fullName: string,\n  +path: Array<string>,\n|}\n\nfunction Name(shortName: string, fullName: string, path: Array<string>) {\n  this.shortName = shortName\n  this.fullName = fullName\n  this.path = path\n}\n\nexport function createName(name: string, parent?: CompositeName) {\n  let path\n  let fullName\n  const shortName = name\n  if (parent === undefined) {\n    if (name.length === 0) {\n      path = ([]: string[])\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    if (name.length === 0) {\n      path = parent.path\n      fullName = parent.fullName\n    } else {\n      path = parent.path.concat([name])\n      if (parent.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + parent.fullName + '/' + name\n      }\n    }\n  }\n  return new Name(shortName, fullName, path)\n}\n","//@flow\n\nexport function thru(fn: Function) {\n  return fn(this)\n}\n","//@flow\n\nimport type {TypeDef, Graph} from '../stdlib'\nimport type {Watcher} from './index.h'\n\nconst noopIndexOf = () => -1\n//eslint-disable-next-line no-unused-vars\nconst noopSplice = (i: number, n: number) => []\n\nfunction disposer() {\n  const i = this.indexOf()\n  if (i === -1) return\n  this.splice(i, 1)\n  this.indexOf = noopIndexOf\n  this.splice = noopSplice\n}\n\nexport const createWatcher = (opts: {|child: Graph, parent: Graph|}): Watcher => {\n  const subscribers = opts.parent.next\n  const instance = {\n    indexOf: subscribers.indexOf.bind(subscribers, opts.child),\n    splice: subscribers.splice.bind(subscribers),\n  }\n  const result = disposer.bind(instance)\n  result.unsubscribe = disposer.bind(instance)\n  return (result: $todo)\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport {step, Kind, stringRefcount, createGraph, type Unit} from '../stdlib'\nimport type {Effect} from '../effect'\nimport {launch} from '../kernel'\nimport {noop} from '../blocks'\n\nimport {getDisplayName} from '../naming'\nimport type {Subscription} from '../index.h'\nimport type {EventConfigPart} from '../config'\nimport type {Event} from './index.h'\nimport {type CompositeName, createName} from '../compositeName'\nimport {thru} from '../thru'\nimport {createLink} from './forward'\n\nconst nextID = stringRefcount()\n\nexport function eventFabric<Payload>({\n  name: nameRaw,\n  parent,\n  config = {},\n}: {\n  name?: string,\n  parent?: CompositeName,\n  config?: EventConfigPart,\n  ...\n}): Event<Payload> {\n  const id = nextID()\n  const name = nameRaw || id\n  const compositeName = createName(name, parent)\n  const fullName = compositeName.fullName\n  const graphite = createGraph({\n    node: [\n      step.emit({\n        fullName,\n      }),\n    ],\n  })\n\n  //$off\n  const instance: Event<Payload> = (\n    payload: Payload,\n    ...args: any[]\n  ): Payload => instance.create(payload, fullName, args)\n  ;(instance: any).getType = () => fullName\n  //eslint-disable-next-line no-unused-vars\n  ;(instance: any).create = (payload, fullName, args) => {\n    launch(instance, payload)\n    return payload\n  }\n  ;(instance: any).kind = Kind.event\n  ;(instance: any)[$$observable] = () => instance\n  ;(instance: any).id = id\n  ;(instance: any).watch = watchEvent.bind(null, instance)\n  ;(instance: any).map = mapEvent.bind(null, instance)\n  ;(instance: any).filter = filterEvent.bind(null, instance)\n  ;(instance: any).prepend = prepend.bind(null, instance)\n  ;(instance: any).subscribe = subscribe.bind(null, instance)\n  ;(instance: any).thru = thru.bind(instance)\n  instance.graphite = graphite\n  instance.shortName = name\n  instance.domainName = parent\n  instance.compositeName = compositeName\n  instance.defaultConfig = config\n\n  return instance\n}\n\nfunction subscribe(event, observer): Subscription {\n  return event.watch(payload => observer.next(payload))\n}\n\nfunction prepend(event, fn: (_: any) => *) {\n  const contramapped: Event<any> = eventFabric({\n    name: '* → ' + event.shortName,\n    parent: event.domainName,\n  })\n  createLink(contramapped, {\n    child: [event],\n    scope: {handler: fn},\n    node: [\n      step.compute({\n        fn: (newValue, {handler}) => handler(newValue),\n      }),\n    ],\n  })\n  return contramapped\n}\n\ndeclare function mapEvent<A, B>(event: Event<A>, fn: (_: A) => B): Event<B>\ndeclare function mapEvent<A, B>(\n  effect: Effect<A, any, any>,\n  fn: (_: A) => B,\n): Event<B>\nfunction mapEvent<A, B>(event: Event<A> | Effect<A, any, any>, fn: A => B) {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' → *',\n    parent: event.domainName,\n  })\n  createLink(event, {\n    child: [mapped],\n    scope: {handler: fn},\n    node: [\n      step.compute({\n        fn: (payload, {handler}) => handler(payload),\n      }),\n    ],\n  })\n  return mapped\n}\n\nfunction filterEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn: {|fn(_: any): boolean|} | (any => any | void),\n): any {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' →? *',\n    parent: event.domainName,\n  })\n  let node\n  let scope\n  //null values not allowed\n  if (typeof fn === 'object') {\n    scope = {fn: fn.fn}\n    node = [\n      step.filter({\n        fn: (upd, {fn}) => fn(upd),\n      }),\n    ]\n  } else {\n    scope = {fn}\n    node = [\n      step.compute({\n        fn: (payload, {fn}) => fn(payload),\n      }),\n      step.filter({\n        fn: result => result !== undefined,\n      }),\n    ]\n  }\n  createLink(event, {\n    scope,\n    child: [mapped],\n    node,\n  })\n  return mapped\n}\n\nfunction watchEvent<Payload>(\n  event: Unit,\n  watcher: (payload: Payload, type: string) => any,\n): Subscription {\n  return createLink(event, {\n    scope: {trigger: event, handler: watcher},\n    //prettier-ignore\n    node: [\n      noop,\n      step.run({\n        fn: (payload: Payload, {trigger, handler}) => handler(\n          payload,\n          getDisplayName(trigger),\n        ),\n      }),\n    ]\n  })\n}\n","//@flow\n\nimport warning from 'warning'\n\nexport type SourceLocation = {|\n  file: string,\n  column: number,\n  line: number,\n|}\n\nexport type EffectConfigPart<Payload, Done> = {\n  handler?: (payload: Payload) => Promise<Done> | Done,\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type StoreConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type EventConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type DomainConfigPart = {\n  name?: string,\n  loc?: SourceLocation,\n  ...\n}\n\nexport type Config<Part> = {\n  ɔ?: Part,\n  ...Part,\n  ...\n}\n\ndeclare export function normalizeConfig<Payload, Done>(\n  config?: Config<EffectConfigPart<Payload, Done>>,\n): EffectConfigPart<Payload, Done>\ndeclare export function normalizeConfig(\n  config?: Config<StoreConfigPart>,\n): StoreConfigPart\ndeclare export function normalizeConfig(\n  config?: Config<EventConfigPart>,\n): EventConfigPart\ndeclare export function normalizeConfig(\n  config?: Config<DomainConfigPart>,\n): DomainConfigPart\nexport function normalizeConfig(config: any = {}): any {\n  const message =\n    'createStore: Second argument should be plain object, but you passed %s.'\n  warning(typeof config === 'object' && config !== null, message, config)\n  if (typeof config?.ɔ !== 'undefined') {\n    warning(\n      typeof config.ɔ === 'object' && config.ɔ !== null,\n      message,\n      config.ɔ,\n    )\n  }\n  const rawConfig = typeof config.ɔ === 'object' ? config.ɔ : {}\n  const newConfig = Object.assign({}, config, rawConfig)\n  delete newConfig.ɔ\n  return newConfig\n}\n\ndeclare export function normalizeEventConfig<Payload, Done>(\n  nameOrConfig?: string | EffectConfigPart<Payload, Done>,\n  config?: Config<EffectConfigPart<Payload, Done>>,\n): {|\n  config: EffectConfigPart<Payload, Done>,\n  name?: string,\n|}\ndeclare export function normalizeEventConfig(\n  nameOrConfig?: string | EventConfigPart,\n  config?: Config<EventConfigPart>,\n): {|\n  config: EventConfigPart,\n  name?: string,\n|}\ndeclare export function normalizeEventConfig(\n  nameOrConfig?: string | DomainConfigPart,\n  config?: Config<DomainConfigPart>,\n): {|\n  config: DomainConfigPart,\n  name?: string,\n|}\nexport function normalizeEventConfig(\n  nameOrConfig?: string | {...},\n  opts?: any,\n) {\n  const config =\n    typeof nameOrConfig === 'object'\n      ? Object.assign({}, normalizeConfig(opts), nameOrConfig)\n      : normalizeConfig(opts)\n  const name =\n    typeof nameOrConfig === 'object' || typeof nameOrConfig === 'undefined'\n      ? config.name\n      : nameOrConfig\n  return {\n    config,\n    name,\n  }\n}\n","//@flow\n\nimport {eventFabric} from './eventFabric'\nimport {\n  normalizeEventConfig,\n  type EventConfigPart,\n  type Config,\n} from '../config'\nimport type {Event} from './index.h'\n\nexport function createEvent<Payload>(\n  nameOrConfig?: string | EventConfigPart,\n  opts?: Config<EventConfigPart> = {},\n): Event<Payload> {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return eventFabric({\n    name,\n    config,\n  })\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport invariant from 'invariant'\nimport {step, readRef, writeRef} from '../stdlib'\nimport {filterChanged, noop} from '../blocks'\nimport {startPhaseTimer, stopPhaseTimer} from '../perf'\nimport {getDisplayName} from '../naming'\nimport {createLink, type Event} from '../event'\nimport type {Store, ThisStore} from './index.h'\nimport type {Subscriber} from '../index.h'\n\nexport function reset(storeInstance: ThisStore, ...events: Array<Event<any>>) {\n  for (const event of events)\n    on.call(this, storeInstance, event, () => storeInstance.defaultState)\n  return this\n}\nexport function getState(storeInstance: ThisStore) {\n  return readRef(storeInstance.plainState)\n}\nexport function off(storeInstance: ThisStore, event: Event<any>) {\n  const currentSubscription = storeInstance.subscribers.get(event)\n  if (currentSubscription === undefined) return\n  currentSubscription()\n  storeInstance.subscribers.delete(event)\n}\n\nexport function on(storeInstance: ThisStore, event: any, handler: Function) {\n  const from: Event<any> = event\n  const oldLink = storeInstance.subscribers.get(from)\n  if (oldLink) oldLink()\n  storeInstance.subscribers.set(\n    from,\n    createLink(from, {\n      scope: {handler, state: storeInstance.plainState, trigger: from},\n      child: [storeInstance],\n      //prettier-ignore\n      node: [\n        step.compute({\n          fn(newValue, {handler, state, trigger}) {\n            const result = handler(\n              readRef(state),\n              newValue,\n              getDisplayName(trigger),\n            )\n            if (result === undefined) return\n            return writeRef(state, result)\n          },\n        }),\n      ]\n    }),\n  )\n  return this\n}\nexport function observable(storeInstance: ThisStore) {\n  const result = {\n    subscribe(observer: Subscriber<any>) {\n      invariant(\n        typeof observer === 'object' && observer !== null,\n        'Expected the observer to be an object.',\n      )\n\n      function observeState(state) {\n        if (observer.next) {\n          observer.next(state)\n        }\n      }\n      return subscribe(storeInstance, observeState)\n    },\n  }\n  //$off\n  result[$$observable] = function() {\n    return this\n  }\n  return result\n}\nexport function watch(\n  storeInstance: ThisStore,\n  eventOrFn: Event<*> | Function,\n  fn?: Function,\n) {\n  const message = 'watch requires function handler'\n  switch (fn && eventOrFn?.kind) {\n    case 'store':\n    case 'event':\n    case 'effect':\n      invariant(typeof fn === 'function', message)\n      return eventOrFn.watch(payload =>\n        //$todo\n        fn(getState(storeInstance), payload, getDisplayName(eventOrFn)),\n      )\n    default:\n      invariant(typeof eventOrFn === 'function', message)\n      return subscribe(storeInstance, eventOrFn)\n  }\n}\nexport function subscribe(storeInstance: ThisStore, listener: Function) {\n  invariant(\n    typeof listener === 'function',\n    'Expected the listener to be a function',\n  )\n  let stopPhaseTimerMessage = 'Got initial error'\n  let lastCall = getState(storeInstance)\n\n  startPhaseTimer(storeInstance, 'subscribe')\n  try {\n    listener(lastCall)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  return createLink(storeInstance, {\n    node: [\n      noop,\n      step.run({\n        fn(args) {\n          let stopPhaseTimerMessage = null\n          startPhaseTimer(storeInstance, 'subscribe')\n          if (args === lastCall) {\n            stopPhaseTimer(stopPhaseTimerMessage)\n            return\n          }\n          lastCall = args\n          try {\n            listener(args)\n          } catch (err) {\n            console.error(err)\n            stopPhaseTimerMessage = 'Got error'\n          }\n          stopPhaseTimer(stopPhaseTimerMessage)\n        },\n      }),\n    ],\n  })\n}\nexport function dispatch(action: any) {\n  return action\n}\n\nexport function mapStore<A, B>(\n  store: Store<A>,\n  fn: (state: A, lastState?: B) => B,\n  firstState?: B,\n): Store<B> {\n  startPhaseTimer(store, 'map')\n  let lastResult\n  let stopPhaseTimerMessage = 'Got initial error'\n  try {\n    const storeState = store.getState()\n    if (storeState !== undefined) {\n      lastResult = fn(storeState, firstState)\n    }\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  const innerStore: Store<any> = this({\n    config: {name: '' + store.shortName + ' → *'},\n    currentState: lastResult,\n    parent: store.domainName,\n  })\n  createLink(store, {\n    child: [innerStore],\n    scope: {store, handler: fn, state: innerStore.stateRef},\n    node: [\n      step.compute({\n        fn(newValue, {state, store, handler}) {\n          startPhaseTimer(store, 'map')\n          let stopPhaseTimerMessage = 'Got error'\n          let result\n          try {\n            result = handler(newValue, readRef(state))\n            stopPhaseTimerMessage = null\n          } catch (err) {\n            console.error(err)\n          }\n          stopPhaseTimer(stopPhaseTimerMessage)\n          return result\n        },\n      }),\n      filterChanged,\n    ],\n  })\n  return innerStore\n}\n","//@flow\nimport $$observable from 'symbol-observable'\n\nimport {launch} from '../kernel'\nimport {step, createGraph, Kind, createStateRef} from '../stdlib'\nimport {createEvent, forward} from '../event'\n\nimport type {Store, ThisStore} from './index.h'\nimport type {StoreConfigPart as ConfigPart} from '../config'\nimport {createName, type CompositeName} from '../compositeName'\nimport {thru} from '../thru'\nimport {\n  reset,\n  getState,\n  off,\n  on,\n  observable,\n  watch,\n  subscribe,\n  dispatch,\n  mapStore,\n} from './storeMethods'\n\nexport function storeFabric<State>(props: {\n  currentState: State,\n  config: ConfigPart,\n  parent?: CompositeName,\n  ...\n}): Store<State> {\n  const {currentState, config, parent} = props\n  const {name} = config\n  const plainState = createStateRef(currentState)\n  const currentId = name || plainState.id\n  const defaultState = currentState\n  const compositeName = createName(currentId, parent)\n\n  const updates: any = createEvent('update ' + currentId)\n  const storeInstance: ThisStore = {\n    graphite: createGraph({\n      scope: {state: plainState, oldState: currentState},\n      node: [\n        step.filter({\n          fn: upd => upd !== undefined,\n        }),\n        step.update({\n          store: plainState,\n        }),\n        step.filter({\n          fn(upd, scope) {\n            if (upd === scope.oldState) return false\n            scope.oldState = upd\n            return true\n          },\n        }),\n      ],\n    }),\n    kind: Kind.store,\n    id: plainState.id,\n    shortName: currentId,\n    domainName: parent,\n    defaultConfig: config,\n    defaultState,\n    plainState,\n    subscribers: new Map(),\n    compositeName,\n  }\n  const store: $Shape<Store<State>> = {\n    compositeName: storeInstance.compositeName,\n    graphite: storeInstance.graphite,\n    kind: Kind.store,\n    id: plainState.id,\n    shortName: currentId,\n    domainName: parent,\n    setState,\n    off: off.bind(null, storeInstance),\n    watch: watch.bind(null, storeInstance),\n    updates,\n    subscribe: subscribe.bind(null, storeInstance),\n    getState: getState.bind(null, storeInstance),\n    stateRef: plainState,\n  }\n  ;(store: any).defaultConfig = config\n  ;(store: any).reset = reset.bind(store, storeInstance)\n  ;(store: any).on = on.bind(store, storeInstance)\n  ;(store: any).defaultState = defaultState\n  ;(store: any).map = mapStore.bind(storeFabric, store)\n  ;(store: any).thru = thru.bind(store)\n  ;(store: any).dispatch = dispatch.bind(null)\n  //$off\n  store[$$observable] = observable.bind(null, storeInstance)\n  forward({\n    from: store,\n    to: updates,\n  })\n\n  function setState(value, reduce?: Function) {\n    const state = getState(storeInstance)\n    const newResult =\n      typeof reduce === 'function' ? reduce(state, value) : value\n\n    launch(store, newResult)\n  }\n\n  return store\n}\n","//@flow\n\nimport invariant from 'invariant'\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\nimport {type Config, type StoreConfigPart, normalizeConfig} from '../config'\n\nexport function createStore<State>(\n  state: State,\n  config: Config<StoreConfigPart> = {},\n): Store<State> {\n  invariant(\n    typeof state !== 'undefined',\n    \"createStore: First argument can't be undefined, use null instead.\",\n  )\n  const opts = normalizeConfig(config)\n  return storeFabric({\n    currentState: state,\n    config: opts,\n  })\n}\n","//@flow\nimport {\n  step,\n  nextBarrierID,\n  createStateRef,\n  readRef,\n  writeRef,\n  type StateRef,\n} from '../stdlib'\nimport {is} from '../validate'\nimport {unitObjectName} from '../naming'\nimport {createLink} from '../event'\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\ntype CombinationScope = {\n  key: any,\n  target: StateRef,\n  clone(value: any): any,\n  isFresh: StateRef,\n  ...\n}\n\nconst storeCombination = (obj: any, clone: Function, defaultState: any) => {\n  const node = [\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {target, key}: CombinationScope) => (\n        upd !== readRef(target)[key]\n      && upd !== undefined\n      ),\n    }),\n    step.tap({\n      fn(upd, {isFresh, target, clone}: CombinationScope) {\n        if (readRef(isFresh)) return\n        writeRef(target, clone(readRef(target)))\n        writeRef(isFresh, true)\n      },\n    }),\n    step.tap({\n      fn(upd, {target, key}: CombinationScope) {\n        readRef(target)[key] = upd\n      },\n    }),\n    step.barrier({barrierID: nextBarrierID()}),\n    step.compute({\n      fn(none, {isFresh, target}: CombinationScope) {\n        writeRef(isFresh, false)\n        return readRef(target)\n      },\n    }),\n  ]\n  const stateNew = clone(defaultState)\n  const store = storeFabric({\n    currentState: stateNew,\n    //TODO: add location\n    config: {name: unitObjectName(obj)},\n  })\n  const isFresh = createStateRef(false)\n  for (const key in obj) {\n    const child = obj[key]\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      continue\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    createLink(child, {\n      scope: {key, clone, target: store.stateRef, isFresh},\n      node,\n      child: [store],\n    })\n  }\n\n  ;(store: any).defaultShape = obj\n  ;(store: any).defaultState = defaultState\n  return store\n}\n\ndeclare export function createStoreObject<\n  State: $ReadOnlyArray<Store<any> | any>,\n>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function createStoreObject<\n  State: {-[key: string]: Store<any> | any, ...},\n>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\n//prettier-ignore\nexport function createStoreObject(obj: *, fn?: Function) {\n  const mergedStore = Array.isArray(obj)\n    ? storeCombination(\n      obj,\n      list => list.slice(),\n      [],\n    )\n    : storeCombination(\n      obj,\n      obj => Object.assign({}, obj),\n      {},\n    )\n  return fn\n    ? mergedStore.map(fn)\n    : mergedStore\n}\n//eslint-disable-next-line\ndeclare export function extract<\n  State: $ReadOnlyArray<Store<any> | any>,\n  NextState: $ReadOnlyArray<Store<any> | any>,\n>(\n  store: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $TupleMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function extract<\n  State: {-[key: string]: Store<any> | any, ...},\n  NextState: {-[key: string]: Store<any> | any, ...},\n>(\n  obj: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $ObjMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function extract(store: Store<any>, extractor: any => any) {\n  let result\n  if ('defaultShape' in store) result = extractor((store: any).defaultShape)\n  else result = extractor((store: any).defaultState)\n  return createStoreObject(result)\n}\n","//@flow\nimport type {Event} from '../event'\nimport type {Effect} from '../effect'\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\nimport {is} from '../validate'\n\nexport function restoreObject<State: {+[key: string]: Store<any> | any, ...}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n> {\n  const result = {}\n  for (const key in obj) {\n    const value = obj[key]\n    if (is.store(value)) {\n      result[key] = value\n    } else {\n      result[key] = storeFabric({\n        currentState: value,\n        config: {name: key},\n      })\n    }\n  }\n  return result\n}\n\nexport function restoreEffect<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done> {\n  const store = storeFabric({\n    currentState: defaultState,\n    parent: event.domainName,\n    //TODO: add location\n    config: {name: event.shortName},\n  })\n  store.on(event.done, (_, {result}) => result)\n  return store\n}\n\nexport function restoreEvent<E>(event: Event<E>, defaultState: E): Store<E> {\n  const store = storeFabric({\n    currentState: defaultState,\n    parent: event.domainName,\n    //TODO: add location\n    config: {name: event.shortName},\n  })\n  store.on(event, (_, v) => v)\n  return store\n}\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function restore<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done>\ndeclare export function restore<E>(event: Event<E>, defaultState: E): Store<E>\ndeclare export function restore<State: {-[key: string]: Store<any> | any, ...}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n>\nexport function restore(obj: any, defaultState: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.event(obj)) {\n    return restoreEvent(obj, defaultState)\n  }\n  if (is.effect(obj)) {\n    return restoreEffect(obj, defaultState)\n  }\n  return restoreObject(obj)\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport {type Store, createStoreObject} from './store'\nimport {is} from './validate'\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function combine<R>(fn: () => R): Store<R>\ndeclare export function combine<A, R>(a: Store<A>, fn: (a: A) => R): Store<R>\ndeclare export function combine<A, B, R>(\n  a: Store<A>,\n  b: Store<B>,\n  fn: (a: A, b: B) => R,\n): Store<R>\ndeclare export function combine<A, B, C, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  fn: (a: A, b: B, c: C) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  fn: (a: A, b: B, c: C, d: D) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  fn: (a: A, b: B, c: C, d: D, e: E) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, K, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  k: Store<K>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) => R,\n): Store<R>\n\nexport function combine(...args: Array<Store<any>>): Store<any> {\n  invariant(args.length > 0, 'at least one argument required')\n  let handler\n  let stores\n  {\n    const rawHandler = args[args.length - 1]\n    if (typeof rawHandler === 'function') {\n      stores = args.slice(0, -1)\n      handler = rawHandler\n    } else {\n      stores = args\n    }\n  }\n\n  let structStoreShape\n\n  makeShape: {\n    if (stores.length === 1) {\n      const obj = stores[0]\n      /*\n      without edge case combine(Color, (Color) => '~')\n      */\n      if (!is.store(obj)) {\n        /*\n        case combine([R,G,B], ([R,G,B]) => '~')\n        case combine({R,G,B}, ({R,G,B}) => '~')\n\n        edge case combine([Color], ([Color]) => '~')\n        edge case combine({Color}, ({Color}) => '~')\n\n        edge case combine([R,G,B])\n        edge case combine({R,G,B})\n\n        edge case combine([Color])\n        edge case combine({Color})\n        */\n        structStoreShape = obj\n        break makeShape\n      }\n    }\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  //$off\n  return createStoreObject(structStoreShape, handler)\n}\n\nconst spreadArgs = fn => list => fn(...list)\n","//@flow\n\nimport warning from 'warning'\nimport type {Effect} from './index.h'\nimport {Kind, step} from '../stdlib'\nimport {upsertLaunch} from '../kernel'\nimport {eventFabric, type Event} from '../event'\nimport {createStore} from '../store'\nimport type {EffectConfigPart} from '../config'\nimport type {CompositeName} from '../compositeName'\n\nfunction OnResolve(result) {\n  const {event, params, handler} = this\n  //prettier-ignore\n  upsertLaunch(event, {\n    handler,\n    toHandler: result,\n    result: {\n      params,\n      result,\n    },\n  })\n}\nfunction OnReject(error) {\n  const {event, params, handler} = this\n  //prettier-ignore\n  upsertLaunch(event, {\n    handler,\n    toHandler: error,\n    result: {\n      params,\n      error,\n    },\n  })\n}\n\nfunction Def() {\n  /*::\n  this.rs = result => {}\n  this.rj = error => {}\n  */\n  const req = new Promise((rs, rj) => {\n    this.rs = rs\n    this.rj = rj\n  })\n  //$off\n  req.anyway = () => {\n    warning(false, '.anyway is deprecated, use .finally')\n    return req.then(() => {}, () => {})\n  }\n  this.req = req\n}\n\nconst notifyHandler = step.run({\n  fn({handler, toHandler, result}, scope) {\n    handler(toHandler)\n    return result\n  },\n})\nexport function effectFabric<Payload, Done>({\n  name,\n  domainName,\n  parent,\n  config,\n}: {\n  name?: string,\n  domainName: string,\n  parent?: CompositeName,\n  config: EffectConfigPart<Payload, Done>,\n  ...\n}): Effect<Payload, Done, *> {\n  const {handler} = config\n\n  //$off\n  const instance: Effect<Payload, Done, any> = eventFabric({\n    name,\n    parent,\n    config,\n  })\n\n  const eventCreate = instance.create\n  const done: Event<{|\n    params: Payload,\n    result: Done\n  |}> = eventFabric({\n    name: '' + instance.shortName + ' done',\n    parent,\n    config,\n  })\n  const fail: Event<{|\n    params: Payload,\n    error: *\n  |}> = eventFabric({\n    name: '' + instance.shortName + ' fail',\n    parent,\n    config,\n  })\n  done.graphite.seq.push(notifyHandler)\n  fail.graphite.seq.push(notifyHandler)\n  //eslint-disable-next-line no-unused-vars\n  let thunk: Function = handler || defaultThunk.bind(instance)\n\n  instance.done = done\n  instance.fail = fail\n  ;(instance: any).use = fn => {\n    thunk = fn\n    return instance\n  }\n  const getCurrent = (): any => thunk\n  ;(instance: any).use.getCurrent = getCurrent\n  ;(instance: any).kind = Kind.effect\n  //assume that fresh event has empty scope\n  ;(instance: any).graphite.scope = {done, fail, getHandler: getCurrent}\n  instance.graphite.seq.push(\n    step.compute({\n      fn(params, scope) {\n        if (typeof params === 'object' && params !== null) {\n          if ('ɔ' in params) return params.ɔ\n        }\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn({params, req}, {getHandler, done, fail}) {\n        runEffect(\n          getHandler(),\n          params,\n          OnResolve.bind({event: done, params, handler: req.rs}),\n          OnReject.bind({event: fail, params, handler: req.rj}),\n        )\n        return params\n      },\n    }),\n  )\n  ;(instance: any).create = (params: Payload, fullName, args) => {\n    const req = new Def()\n    eventCreate({ɔ: {params, req}}, instance.getType(), args)\n    return req.req\n  }\n  /* terser will minify true and false to 1 and 0,\n    thereby we need to define true as Boolean(1)\n    and false as Boolean(0) */\n  instance.pending = createStore(Boolean(0))\n    .on(instance, () => Boolean(1))\n    .reset(done)\n    .reset(fail)\n  return instance\n}\nfunction runEffect(handler, params, onResolve, onReject) {\n  let failedSync = false\n  let syncError\n  let rawResult\n  try {\n    rawResult = handler(params)\n  } catch (err) {\n    failedSync = true\n    syncError = err\n  }\n  if (failedSync) {\n    onReject(syncError)\n    return\n  }\n  if (typeof rawResult === 'object' && rawResult !== null) {\n    if (typeof rawResult.then === 'function') {\n      rawResult.then(onResolve, onReject)\n      return\n    }\n  }\n  onResolve(rawResult)\n}\n//eslint-disable-next-line no-unused-vars\nfunction defaultThunk(value) {\n  warning(false, 'no thunk used in %s', this.getType())\n  return Promise.resolve()\n}\n","//@flow\n/* eslint-disable */\nimport {__DEV__} from 'effector/flags'\n\nexport default (__DEV__\n  ? function invariant(condition: any, format: string, ...args: any) {\n      if (!condition) {\n        const error = Error()\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(error, invariant)\n        }\n        error.name = 'Invariant Violation'\n        let argIndex = 0\n        error.message = format.replace(/%s/g, () => args[argIndex++])\n        throw error\n      }\n    }\n  : function invariant(condition: any /*::, format: string, ...args: any*/) {\n      if (!condition) {\n        throw Error('Minified exception occurred')\n      }\n    })\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","//@flow\n\nimport type {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const stringRefcount = (): (() => string) => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n","//@flow\nimport type {\n  StateRef,\n  NodeMeta,\n  Update,\n  Run,\n  Tap,\n  Filter,\n  Emit,\n  Compute,\n  Barrier,\n  ID,\n} from './index.h'\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\n\nconst cmd = (type: any, data: any): any => ({\n  id: nextID(),\n  type,\n  group: 'cmd',\n  data,\n})\n\nexport const step: {|\n  barrier(data: {|\n    +barrierID: ID,\n    +priority?: 'barrier' | 'sampler',\n    meta?: NodeMeta,\n  |}): Barrier,\n  emit(data: {|\n    fullName: string,\n    meta?: NodeMeta,\n  |}): Emit,\n  compute(data: {|\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  |}): Compute,\n  filter(data: {|\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  |}): Filter,\n  run(data: {\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  }): Run,\n  tap(data: {\n    fn: (data: any, scope: {[string]: any, ...}) => any,\n    meta?: NodeMeta,\n  }): Tap,\n  update(data: {|\n    store: StateRef,\n    meta?: NodeMeta,\n  |}): Update,\n|} = {\n  barrier: ({barrierID, priority = 'barrier'}) =>\n    cmd('barrier', {\n      barrierID,\n      priority,\n    }),\n  compute: cmd.bind(null, 'compute'),\n  emit: cmd.bind(null, 'emit'),\n  filter: cmd.bind(null, 'filter'),\n  run: cmd.bind(null, 'run'),\n  tap: cmd.bind(null, 'tap'),\n  update: cmd.bind(null, 'update'),\n}\n","//@flow\nimport type {StateRef} from './index.h'\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextID(),\n  current,\n})\n\nexport const readRef = ({current}: StateRef | {current: any, ...}) => current\nexport const writeRef = (ref: StateRef | {current: any, ...}, value: any) =>\n  (ref.current = value)\n","//@flow\n\nimport {stringRefcount} from './refcount'\nexport const nextBarrierID = stringRefcount()\n","// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n//@flow\n/* eslint-disable */\n\nexport type PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\nexport const getPriority = (t: PriorityTag) => {\n  switch(t) {\n    case 'child': return 0\n    case 'pure': return 1\n    case 'barrier': return 2\n    case 'sampler': return 3\n    case 'effect': return 4\n    default: return -1\n  }\n}","//@flow\n\nimport type {\n  Graph,\n  Graphite,\n  StateRef,\n  Cmd,\n  Emit,\n  Run,\n  Update,\n  Filter,\n  Compute,\n  Barrier,\n  Tap,\n} from '../stdlib'\nimport {getGraph, writeRef, readRef} from '../stdlib'\n\nimport {getPriority, type PriorityTag} from './getPriority'\n\nclass Stack {\n  /*::\n  value: {current: any}\n  parent: Stack | null\n  */\n  constructor(value: any, parent: Stack | null) {\n    this.value = {current: value}\n    this.parent = parent\n  }\n}\n\ntype Layer = {|\n  +step: Graph,\n  +firstIndex: number,\n  +scope: Stack,\n  +resetStop: boolean,\n  +type: PriorityTag,\n  +id: number,\n|}\n\nexport class Leftist {\n  /*::\n  left: leftist\n  right: leftist\n  value: Layer\n  rank: number\n  */\n  constructor(value: Layer, rank: number, left: leftist, right: leftist) {\n    this.value = value\n    this.rank = rank\n    this.left = left\n    this.right = right\n  }\n}\nexport type leftist = null | Leftist\nconst insert = (x: Layer, t: leftist): leftist =>\n  merge(new Leftist(x, 1, null, null), t)\n\nconst deleteMin = (param: leftist): leftist => {\n  if (param) {\n    return merge(param.left, param.right)\n  }\n  return null\n}\nconst merge = (_t1: leftist, _t2: leftist): leftist => {\n  let t2\n  let t1\n  let k1\n  let l\n  let merged\n  let rank_left\n  let rank_right\n  while (true) {\n    t2 = _t2\n    t1 = _t1\n    if (!t1) return t2\n    if (!t2) return t1\n    k1 = t1.value\n    l = t1.left\n    if (layerComparator(k1, t2.value)) {\n      _t2 = t1\n      _t1 = t2\n      continue\n    }\n    merged = merge(t1.right, t2)\n    rank_left = l?.rank || 0\n    rank_right = merged?.rank || 0\n    if (rank_left >= rank_right) {\n      return new Leftist(k1, rank_right + 1, l, merged)\n    }\n    return new Leftist(k1, rank_left + 1, merged, l)\n  }\n  /*::return _t1*/\n}\nclass Local {\n  /*::\n  isChanged: boolean\n  isFailed: boolean\n  scope: {[key: string]: any, ...}\n  */\n  constructor(scope: {[key: string]: any, ...}) {\n    this.isChanged = true\n    this.isFailed = false\n    this.scope = scope\n  }\n}\nconst layerComparator = (a: Layer, b: Layer) => {\n  if (a.type === b.type) return a.id > b.id\n  return getPriority(a.type) > getPriority(b.type)\n}\nlet layerID = 0\nlet heap: leftist = null\nconst barriers = new Set()\nconst pushHeap = (opts: Layer) => {\n  heap = insert(opts, heap)\n}\nconst runGraph = ({step: graph, firstIndex, scope, resetStop}: Layer, meta) => {\n  const local = new Local(graph.scope)\n  for (\n    let stepn = firstIndex;\n    stepn < graph.seq.length && !meta.stop;\n    stepn++\n  ) {\n    const step = graph.seq[stepn]\n    if (stepn === firstIndex) {\n      if (step.type === 'barrier') {\n        barriers.delete(step.data.barrierID)\n      }\n    } else {\n      switch (step.type) {\n        case 'run':\n          pushHeap({\n            step: graph,\n            firstIndex: stepn,\n            scope,\n            resetStop: false,\n            type: 'effect',\n            id: ++layerID,\n          })\n          return\n        case 'barrier': {\n          const id = step.data.barrierID\n          if (!barriers.has(id)) {\n            barriers.add(id)\n            pushHeap({\n              step: graph,\n              firstIndex: stepn,\n              scope,\n              resetStop: false,\n              type: step.data.priority,\n              id: ++layerID,\n            })\n          }\n          return\n        }\n      }\n    }\n    const cmd = command[step.type]\n    //$todo\n    cmd(local, step.data, scope.value)\n    meta.stop = local.isFailed || !local.isChanged\n  }\n  if (!meta.stop) {\n    for (let stepn = 0; stepn < graph.next.length; stepn++) {\n      /**\n       * copy head of scope stack to feel free\n       * to override it during seq execution\n       */\n      const subscope = new Stack(readRef(scope.value), scope)\n      pushHeap({\n        step: graph.next[stepn],\n        firstIndex: 0,\n        scope: subscope,\n        resetStop: true,\n        type: 'child',\n        id: ++layerID,\n      })\n    }\n  }\n  if (resetStop) {\n    meta.stop = false\n  }\n}\n\nlet alreadyStarted = false\n\nconst addSingleBranch = (unit: Graphite, payload: any) => {\n  pushHeap({\n    step: getGraph(unit),\n    firstIndex: 0,\n    scope: new Stack(payload, null),\n    resetStop: false,\n    type: 'pure',\n    id: ++layerID,\n  })\n}\n\nconst exec = () => {\n  const lastStartedState = alreadyStarted\n  alreadyStarted = true\n  const meta = {\n    stop: false,\n  }\n  let value\n  while (heap) {\n    value = heap.value\n    heap = deleteMin(heap)\n    runGraph(value, meta)\n  }\n  alreadyStarted = lastStartedState\n}\nexport const launch = (unit: Graphite, payload: any) => {\n  addSingleBranch(unit, payload)\n  exec()\n}\nexport const upsertLaunch = (unit: Graphite, payload: any) => {\n  addSingleBranch(unit, payload)\n  if (alreadyStarted) return\n  exec()\n}\nconst command = {\n  barrier(local, step: $PropertyType<Barrier, 'data'>, val: StateRef) {\n    local.isFailed = false\n    local.isChanged = true\n  },\n  emit(local, step: $PropertyType<Emit, 'data'>, val: StateRef) {},\n  filter(local, step: $PropertyType<Filter, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    /**\n     * .isFailed assignment is not needed because in such case\n     * runCtx.result will be null\n     * thereby successfully forcing that branch to stop\n     */\n    local.isChanged = !!runCtx.result\n  },\n  run(local, step: $PropertyType<Run, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n    writeRef(val, runCtx.result)\n  },\n  update(local, step: $PropertyType<Update, 'data'>, val: StateRef) {\n    writeRef(step.store, readRef(val))\n  },\n  compute(local, step: $PropertyType<Compute, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n    writeRef(val, runCtx.result)\n  },\n  tap(local, step: $PropertyType<Tap, 'data'>, val: StateRef) {\n    const runCtx = tryRun({\n      arg: readRef(val),\n      val: local.scope,\n      fn: step.fn,\n    })\n    local.isFailed = runCtx.err\n  },\n}\nconst tryRun = ({fn, arg, val}: any) => {\n  const result = {\n    err: false,\n    result: null,\n  }\n  try {\n    result.result = fn(arg, val)\n  } catch (err) {\n    console.error(err)\n    result.err = true\n  }\n  return result\n}\n","//@flow\n\nimport {step, readRef} from './stdlib'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== readRef(state)\n    && data !== undefined\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n","//@flow\nimport {__DEV__} from 'effector/flags'\n\nexport default (__DEV__\n  ? (condition: any, format: string, ...args: any) => {\n    if (!condition) {\n      console.error('Warning: ' + format, ...args)\n    }\n  }\n  : (/*::condition: any, format: string, ...args: any*/) => {})\n","//@flow\n\nimport {Kind, type kind} from '../stdlib'\n\nexport const unit = (obj: mixed) =>\n  (typeof obj === 'function' || (typeof obj === 'object' && obj !== null))\n  //$off\n  && 'kind' in obj\n\n//$off\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(Kind.store)\nexport const event = is(Kind.event)\nexport const effect = is(Kind.effect)\nexport const domain = is(Kind.domain)\n","//@flow\nimport {type Graphite, type Cmd, getGraph, createGraph} from '../stdlib'\nimport type {Subscription} from '../index.h'\nimport {createWatcher} from '../watcher'\n\nexport const createLink = (\n  from: Graphite,\n  opts: {|\n    +node: Array<Cmd>,\n    +child?: Array<Graphite>,\n    scope?: {[name: string]: any, ...},\n    meta?: {[name: string]: any, ...},\n  |},\n) =>\n  forward({\n    from,\n    to: createGraph(opts),\n  })\n\nexport const forward = (opts: {|\n  from: Graphite,\n  to: Graphite\n|}): Subscription => {\n  const from = getGraph(opts.from)\n  const to = getGraph(opts.to)\n  from.next.push(to)\n  //TODO push parent to .from field\n  // to.from.push(from)\n  return createWatcher({\n    child: to,\n    parent: from,\n  })\n}\n","//@flow\n/* eslint-disable no-nested-ternary */\nimport {is} from './validate'\nimport {eventFabric, createLink, forward} from './event'\nimport {storeFabric, createStoreObject} from './store'\nimport {noop} from './blocks'\nimport {\n  step,\n  type Graphite,\n  createStateRef,\n  readRef,\n  writeRef,\n  nextBarrierID,\n} from './stdlib'\n\nconst storeBy = (source, clock, fn, greedy, target) => {\n  createLink(clock, {\n    scope: {\n      state: source.stateRef,\n      fn,\n    },\n    child: [target],\n    node: [\n      //$off\n      !greedy && noop,\n      //$off\n      !greedy\n        && step.barrier({\n          barrierID: nextBarrierID(),\n          priority: 'sampler',\n        }),\n      step.compute({\n        fn: fn\n          ? (upd, {state, fn}) => fn(readRef(state), upd)\n          : (upd, {state}) => readRef(state),\n      }),\n    ].filter(Boolean),\n  })\n  return target\n}\n\nconst storeByEvent = (source: any, clock: any, fn: any, greedy, target) =>\n  storeBy(\n    source,\n    clock,\n    fn,\n    greedy,\n    target\n      || eventFabric({\n        name: source.shortName,\n        parent: source.domainName,\n      }),\n  )\n\nconst storeByStore = (source: any, clock: any, fn: any, greedy, target) => {\n  const sourceState = readRef(source.stateRef)\n  return storeBy(\n    source,\n    clock,\n    fn,\n    greedy,\n    target\n      || storeFabric({\n        currentState: fn\n          ? fn(sourceState, readRef(clock.stateRef))\n          : sourceState,\n        config: {name: source.shortName},\n        parent: source.domainName,\n      }),\n  )\n}\n\nconst eventByUnit = (source: any, clock: any, fn: any, greedy, target) => {\n  target =\n    target\n    || eventFabric({\n      name: source.shortName,\n      parent: source.domainName,\n    })\n  const hasSource = createStateRef(false)\n  const sourceState = createStateRef()\n  const clockState = createStateRef()\n\n  createLink(source, {\n    scope: {hasSource},\n    node: [\n      step.update({store: sourceState}),\n      step.tap({\n        fn(upd, {hasSource}) {\n          writeRef(hasSource, true)\n        },\n      }),\n    ],\n  })\n\n  createLink(clock, {\n    scope: {sourceState, clockState, hasSource, fn},\n    child: [target],\n    node: [\n      step.update({store: clockState}),\n      step.filter({\n        fn: (upd, {hasSource}) => readRef(hasSource),\n      }),\n      //$off\n      !greedy\n        && step.barrier({\n          barrierID: nextBarrierID(),\n          priority: 'sampler',\n        }),\n      step.compute({\n        fn: fn\n          ? (upd, {sourceState, clockState, fn}) =>\n            fn(readRef(sourceState), readRef(clockState))\n          : (upd, {sourceState}) => readRef(sourceState),\n      }),\n    ].filter(Boolean),\n  })\n  return target\n}\n\nexport function sample(\n  source: any,\n  clock: Graphite,\n  fn?: boolean | ((source: any, clock: any) => any),\n  greedy: boolean = false,\n): any {\n  let target\n  //config case\n  if (clock === undefined && 'source' in source) {\n    clock = source.clock || source.sampler\n    fn = source.fn\n    greedy = source.greedy\n    //optional target accepted only from config\n    target = source.target\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  const sourceNorm = unitOrCombine(source)\n  const clockNorm = unitOrCombine(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = undefined\n  }\n  //prettier-ignore\n  const combinator =\n    is.store(sourceNorm)\n      ? is.store(clockNorm)\n        ? storeByStore\n        : storeByEvent\n      : eventByUnit\n  return combinator(sourceNorm, clockNorm, fn, greedy, target)\n}\n\n//prettier-ignore\nconst unitOrCombine = (obj: any) => is.unit(obj)\n  ? obj\n  : createStoreObject(obj)\n","//@flow\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {Store} from '../store'\nimport {type Event, eventFabric} from '../event'\nimport type {Effect} from '../effect'\nimport type {CompositeName} from '../compositeName'\nexport class DomainHistory {\n  /*::;+*/ events: Set<Event<any>> = new Set()\n  /*::;+*/ effects: Set<Effect<any, any, any>> = new Set()\n  /*::;+*/ storages: Set<Store<any>> = new Set()\n  /*::;+*/ domains: Set<Domain> = new Set()\n}\n\nexport function domainHooks(\n  history: DomainHistory,\n  compositeName: CompositeName,\n  parentHooks?: DomainHooks,\n) {\n  let hooks: {|\n    domain: Event<Domain>,\n    effect: Event<Effect<any, any, any>>,\n    event: Event<Event<any>>,\n    store: Event<any>,\n  |}\n  if (parentHooks) {\n    hooks = childDomainHooks(parentHooks)\n  } else {\n    hooks = singleDomainHooks(compositeName)\n  }\n  hooks.domain.watch(domain => {\n    history.domains.add(domain)\n  })\n  hooks.event.watch(event => {\n    history.events.add(event)\n  })\n  hooks.store.watch(store => {\n    history.storages.add(store)\n  })\n  hooks.effect.watch(effect => {\n    history.effects.add(effect)\n  })\n  return hooks\n}\n\nconst singleDomainHooks = (compositeName: CompositeName) => {\n  const event: Event<Event<any>> = eventFabric({\n    name: `${compositeName.fullName} event hook`,\n    parent: compositeName,\n  })\n  const effect: Event<Effect<any, any, any>> = eventFabric({\n    name: `${compositeName.fullName} effect hook`,\n    parent: compositeName,\n  })\n  const store: Event<Store<any>> = eventFabric({\n    name: `${compositeName.fullName} store hook`,\n    parent: compositeName,\n  })\n  const domain: Event<Domain> = eventFabric({\n    parent: compositeName,\n  })\n  return {event, effect, store, domain}\n}\n\nconst childDomainHooks = (parentHooks: DomainHooks) => {\n  const event: Event<Event<any>> = parentHooks.event.prepend(_ => _)\n  const effect: Event<Effect<any, any, any>> = parentHooks.effect.prepend(\n    _ => _,\n  )\n  const store: Event<Store<any>> = parentHooks.store.prepend(_ => _)\n  const domain: Event<Domain> = parentHooks.domain.prepend(_ => _)\n  return {event, effect, store, domain}\n}\n","//@flow\n\nimport {stringRefcount, Kind} from '../stdlib'\nimport {type Store, storeFabric} from '../store'\nimport {\n  normalizeConfig,\n  type Config,\n  type EffectConfigPart,\n  type EventConfigPart,\n  type StoreConfigPart,\n} from '../config'\nimport {type Event, eventFabric} from '../event'\nimport {type Effect, effectFabric} from '../effect'\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {DomainConfigPart} from '../config'\nimport {createName, type CompositeName} from '../compositeName'\nimport {DomainHistory, domainHooks} from './hook'\n\nconst nextID = stringRefcount()\n\nexport function domainFabric({\n  name: nameRaw,\n  config = {},\n  parent,\n  parentHooks,\n}: {\n  name?: string,\n  config?: DomainConfigPart,\n  parent?: CompositeName,\n  parentHooks?: DomainHooks,\n  ...\n}): Domain {\n  const id = nextID()\n  const name = nameRaw || ''\n  const compositeName = createName(name, parent)\n  const history = new DomainHistory()\n  const hooks = domainHooks(history, compositeName, parentHooks)\n\n  return {\n    compositeName,\n    id,\n    defaultConfig: config,\n    getType() {\n      return compositeName.fullName\n    },\n    onCreateEvent(hook: (newEvent: Event<any>) => any) {\n      history.events.forEach(hook)\n      return hooks.event.watch(hook)\n    },\n    onCreateEffect(hook: (newEffect: Effect<any, any, any>) => any) {\n      history.effects.forEach(hook)\n      return hooks.effect.watch(hook)\n    },\n    onCreateStore(hook: (newStore: Store<any>) => any) {\n      history.storages.forEach(hook)\n      return hooks.store.watch(hook)\n    },\n    onCreateDomain(hook: (newDomain: Domain) => any) {\n      history.domains.forEach(hook)\n      return hooks.domain.watch(hook)\n    },\n    event<Payload>(\n      name?: string,\n      config: Config<EventConfigPart> = {},\n    ): Event<Payload> {\n      const opts = normalizeConfig(config)\n      const result = eventFabric({\n        name,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.event(result)\n      return result\n    },\n    effect<Params, Done, Fail>(\n      name?: string,\n      config: Config<EffectConfigPart<Params, Done>> = {},\n    ): Effect<Params, Done, Fail> {\n      const opts = normalizeConfig(config)\n      const result = effectFabric({\n        name,\n        domainName: compositeName.fullName,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.effect(result)\n      return result\n    },\n    domain(name?: string, config: Config<DomainConfigPart> = {}) {\n      const opts = normalizeConfig(config)\n      const result = domainFabric({\n        name,\n        parent: compositeName,\n        parentHooks: hooks,\n        config: opts,\n      })\n      hooks.domain(result)\n      return result\n    },\n    store<T>(state: T, config: Config<StoreConfigPart> = {}): Store<T> {\n      const opts = normalizeConfig(config)\n      const result = storeFabric({\n        currentState: state,\n        parent: compositeName,\n        config: opts,\n      })\n      hooks.store(result)\n      return result\n    },\n    kind: Kind.domain,\n  }\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {type Event, createEvent} from '../event'\n\ndeclare export function createApi<\n  S,\n  Obj: {-[name: string]: (store: S, e: any) => S, ...},\n>(\n  store: Store<S>,\n  setters: Obj,\n): $ObjMap<Obj, <E>(h: (store: S, e: E) => S) => Event<E>>\n\nexport function createApi(store: Store<any>, setters: {[string]: Function, ...}) {\n  const result = {}\n  for (const key in setters) {\n    const handler: any = setters[key]\n    const event = (result[key] = createEvent(key))\n    store.on(event, handler)\n  }\n  return result\n}\n","//@flow\n\nimport {domainFabric} from './domainFabric'\nimport {normalizeEventConfig, type Config, type DomainConfigPart} from '../config'\n\nexport function createDomain(\n  nameOrConfig?: string | DomainConfigPart,\n  opts?: Config<DomainConfigPart> = {},\n) {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return domainFabric({\n    name: name === undefined ? '' : name,\n    config,\n  })\n}\n","//@flow\n\nimport {effectFabric} from './effectFabric'\nimport {\n  normalizeEventConfig,\n  type EffectConfigPart,\n  type Config,\n} from '../config'\nimport type {Effect} from './index.h'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig?: string | EffectConfigPart<Payload, Done>,\n  opts?: Config<EffectConfigPart<Payload, Done>>,\n): Effect<Payload, Done, *> {\n  const {config, name} = normalizeEventConfig(nameOrConfig, opts)\n  return effectFabric({\n    name,\n    domainName: '',\n    config,\n  })\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport $$observable from 'symbol-observable'\nimport {clearNode} from '../stdlib'\nimport {createEvent} from './createEvent'\nimport type {Event} from './index.h'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  invariant(\n    typeof observable === 'function'\n      || (typeof observable === 'object' && observable !== null),\n    'expect observable to be object or function',\n  )\n  const observableItem: any =\n    //$off\n    ($$observable: '@@observable') in observable\n      ? //$off\n      observable[(($$observable: any): '@@observable')]()\n      : observable\n  invariant(\n    'subscribe' in observableItem,\n    'expect observable to have .subscribe',\n  )\n  const event: Event<T> = createEvent()\n  const disposer = clearNode.bind(null, event, {})\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\n\nimport {is} from '../validate'\nimport {__DEBUG__} from 'effector/flags'\nimport type {Store} from './index.h'\nimport {createName} from '../compositeName'\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, store.domainName)\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  //$todo\n  store.compositeName.path = compositeName.path\n  //$todo\n  store.compositeName.shortName = compositeName.shortName\n  //$todo\n  store.compositeName.fullName = compositeName.fullName\n}\n\nexport function storeNaming<Obj: {[key: string]: Store<any> | Object, ...}>(\n  object: Obj,\n  parent?: Store<any>,\n) {\n  for (const storeName in object) {\n    const store: Store<any> = object[storeName]\n    if (!is.store(store)) {\n      console.warn(\n        'effector: Key \"%s\" must be store but instead received %s',\n        storeName,\n        store.kind || '\"' + typeof store + '\"',\n        store,\n      )\n      continue\n    }\n    if (parent) {\n      store.domainName = parent.compositeName || store.domainName\n    }\n    setStoreName(store, storeName)\n    if (store.defaultShape !== undefined) {\n      storeNaming(store.defaultShape, store)\n    }\n  }\n}\n","//@flow\n\nimport type {Store} from './index.h'\n\nexport function withProps<R, S, P>(\n  store: Store<S>,\n  handler: (store: S, props: P) => R,\n): (props: P) => R {\n  return (props: P) => handler(store.getState(), props)\n}\n"],"names":["createGraph","node","child","from","scope","meta","map","getGraph","seq","next","getDisplayName","unit","compositeName","fullName","domainName","id","unitObjectName","objOrArr","i","arr","Object","values","max","unitObjectMaxNames","maxLength","length","name","comma","is","toString","Name","shortName","path","createName","parent","undefined","concat","thru","fn","this","disposer","indexOf","splice","noopIndexOf","noopSplice","eventFabric","nameRaw","config","nextID","graphite","step","emit","instance","payload","args","create","getType","launch","kind","Kind","$$observable","watch","event","watcher","createLink","trigger","handler","noop","run","bind","mapped","compute","filter","upd","result","prepend","contramapped","newValue","subscribe","observer","defaultConfig","normalizeConfig","ɔ","warning","newConfig","assign","normalizeEventConfig","nameOrConfig","opts","createEvent","getState","storeInstance","readRef","plainState","off","currentSubscription","subscribers","get","delete","on","oldLink","set","state","writeRef","eventOrFn","message","invariant","listener","stopPhaseTimerMessage","lastCall","err","console","error","storeFabric","props","currentState","createStateRef","currentId","defaultState","updates","oldState","update","store","Map","setState","value","reduce","newResult","stateRef","reset","events","call","firstState","lastResult","storeState","innerStore","filterChanged","dispatch","action","forward","to","createStore","createStoreObject","obj","mergedStore","Array","isArray","storeCombination","list","slice","restoreObject","key","restoreEffect","done","_","restoreEvent","v","combine","stores","structStoreShape","rawHandler","makeShape","spreadArgs","Def","req","Promise","rs","rj","anyway","then","effectFabric","eventCreate","fail","push","notifyHandler","thunk","resolve","use","getCurrent","getHandler","params","data","onResolve","onReject","syncError","rawResult","failedSync","runEffect","upsertLaunch","toHandler","pending","Boolean","condition","Error","Symbol","self","window","global","module","Function","observable","ponyfill","effect","stringRefcount","cmd","type","group","barrier","barrierID","priority","tap","clearNode","deep","graph","forEach","index","current","ref","nextBarrierID","getPriority","t","Stack","constructor","Leftist","rank","left","right","deleteMin","param","merge","_t1","_t2","t2","t1","k1","l","merged","rank_left","rank_right","layerComparator","Local","isChanged","isFailed","a","b","layerID","heap","barriers","Set","pushHeap","x","insert","runGraph","firstIndex","resetStop","local","stepn","stop","has","add","command","subscope","alreadyStarted","addSingleBranch","exec","lastStartedState","val","runCtx","tryRun","arg","n","domain","unsubscribe","createWatcher","clone","target","isFresh","none","stateNew","defaultShape","storeBy","source","clock","greedy","unitOrCombine","DomainHistory","effects","storages","domains","setters","domainFabric","parentHooks","history","hooks","childDomainHooks","singleDomainHooks","domainHooks","onCreateEvent","hook","onCreateEffect","onCreateStore","onCreateDomain","extractor","observableItem","complete","sampler","sourceNorm","clockNorm","sourceState","hasSource","clockState","rawName"],"mappings":"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"}